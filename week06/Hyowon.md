## 6.1 웹 중개자

- 웹 프락시 서버는 클라이언트의 입장에서 트랙잭션을 수행하는 중개인이다.
- 웹 프락시가 없다면 클라이언트는 http서버와 직접 이야기한다.
- 웹 프락시가 있다면 클라이언트는 프락시와 이야기한다.
- 트랜잭션을 완료하는 것이 클라이언트라는 점은 변하지 않지만, 프락시 서버가 제공하는 좋은 서비스를 이용할 수 있다.
- 프락시는 웹서버 이기도 하고 웹클라이언트이기도 하다

### 6.1.1 개인프락시와 공유 프락시

- 대부분 프락시는 공용이다
- 캐시 프락시 서버와 같은 몇몇 프락시 애플리케이션은 프락시를 이용하는 사용자가 많을 수록 유리하다
    
    → 여러 사용자들의 공통된 요청에서 이득을 취할 수 있기 때문
    
- 개인 전용 프락시는 흔하지 않지만 꾸준히 사용된다(특히 클라이언트 컴퓨터에서 직접 실행되는 형태로)

### 6.1.2 프락시 대 게이트웨이

- 프락시
    - 같은 프로토콜을 사용하는 둘 이상의 애플리케이션을 연결
- 게이트웨이
    - 서로 다른 프로토콜을 사용하는 둘 이상을 연결
    - 다른 프로토콜로 말하더라도 서로 트랜잭션을 완료할 수 있도록 해주는 프로토콜 변환기처럼 동작한다.
- 실질적으로 프락시와 게이트웨이의 차이점은 모호하다
    - 브라우저와 서버가 서로 다른 버전의 http를 구현하기 때문에 프락시가 약간의 프로토콜 변환을 하기도 함
    - 그리고 상용 프락시 서버가 게이트웨이 기능을 구현하기도 함 ( ssl 보안 프로토콜, socks 방화벽, ftp 접근 등)
    

## 6.2 왜 프락시를 사용하는가?

- 프락시 서버가 하는일
    - 실용적이고 유용한 것이라면 무슨 일이든 한다
    - 보안을 개선, 성능 높이기, 비용 절약
    - 트래픽을 감시하고 수정
- 어린이들에게 성인콘텐츠를 차단하는 필터링 프락시
- 문서 접근 제어자
    - 다양한 종류의 수많은 웹 서버들에 대한 접근 제어를 수시로 갱신할 필요 없이, 중앙 프락시 서버에게 접근 제어를 설정할 수 있다.
    - 똑똑한 사용자들이 고의적으로 프락시를 피해가는 것을 방지하기 위해, 웹 서버가 고정적으로 프락시 서버로부터의 요청만 받아들이도록 설정할 수도 있다.
- 보안 방화벽
    - 종종 보안을 강화하기 위해 사용한다
    - 조직안에 들어오거나 나가는 응용레벨 프로토콜 흐름을 네트웨크의 한 지점에서 통제한다
- 웹 캐시
    - 인기 있는 문서의 로컬 사본을 관리하고 해당 문서에 대한 요청이 오면 빠르게 제공한다
- 대리 프락시(리버스 프락시 혹은 서버가속기)
    - 어떤 프락시들은 웹 서버인 것 처럼 위장한다.
    - 웹 서버 요청을 받지만, 웹 서버와는 달리 요청 받은 콘텐츠의 위치를 찾아내기 위해 다른 서버와 커뮤니케이션을 시작한다.
    - 대리 프락시는 공용 콘텐츠에 대한 느린 웹 서버의 성능을 개선하기 위해 사용될 수 있다.
- 콘텐츠 라우터
    - 인터넷 트래픽 조건과 콘텐츠의 종류에 따라 요청을 특정 웹서버로 유도한다.
- 트랜스코더
    - 클라이언트에게 콘텐츠를 전달하기 전에 본문 포맷을 수정할 수 있음
    - 트랜스코딩: 데이터의 표현 방식을 자연스럽게 변환하는 것
    - 트랜스코딩 프락시는 크기를 줄이기 위해 자신을 거쳐가는 gif 이미지를 jpg이미지로 변환할 수 있다.
    - 문서를 바로 외국어 문서로 변환하는 것 또한 가능하다.
- 익명화 프락시
    - http 메시지에서 신원을 식별할 수 있는 특성들 (ip주소, from헤더, referer헤더, 쿠키, uri 세션 아이디)를 적극적으로 제거함으로써 개인 정보 보호와 익명성 보장에 기여한다.

## 6.3 프락시는 어디에 있는가?

### 6.3.1 프락시 서버 배치

- 출구 프락시
    - 필터링 프락시
- 접근(입구) 프락시
    - 캐시 프락시
- 대리 프락시
    - 네트워크의 가장 끝에 있는 웹 서버들의 바로 앞에 위치
- 네트웨크 교환 프락시
    - 네트워크 사이의 인터넷 피어링 교환 지점들
    

### 6.3.2 프락시 계층

- 프락시들은 프락시 계층이라고 불리는 연쇄를 구성할 수 있다.
- 프락시 계층에서 프락시 서버들은 부모와 자식의 관계를 갖는다.
- 인바운드 프락시: 서버에 가까운 쪽, 부모
- 아웃바운드 프락시: 클라이언트에 가까운쪽, 자식

- 프락시 계층 콘텐츠 라우팅
    - 프락시 계층은 정적이다
    - 반드시 정적이어야 하는 것은 아니다
    - 동적 부모 선택의 예시
        - 부하 균형
        - 지리적 인접성에 근거한 라우팅
        - 프로토콜/타입 라우팅
        - 유료 서비스 가입자를 위한 라우팅
    

### 6.3.3 어떻게 프락시가 트래픽을 처리하는가

- 클라이언트 트래픽이 프락시로 가도록 만드는 방법
    - 클라이언트를 수정한다
    - 네트워크를 수정한다
    - dns 이름공간을 수정한다
    - 웹 서버를 수정한다.
    

## 6.4 클라이언트 프록시 설정

- 수동 설정
- 브라우저 기본 설정
- 프락시 자동 설정(PAC)
- WPAD 프락시 발견

## 6.5 프락시 요청의 미묘한 특징들

### 6.5.1 프락시 URI는 서버 URI와 다르다

- 클라이언트가 프락시 대신 서버로 요청을 보내면 요청의 URI가 달라진다.
- 클라이언트가 웹 서버로 요청을 보낼 때
    - 스킴, 호스트, 포트번호가 없는 부분 URI를 가진다
    - 가상호스팅이나 프락시에 대한 대비가 없을 때는 불필요한 정보 발성을 피하기 위해서 부분 URI만 보냄
- 클라이언트가 프락시로 요청을 보낼때
    - 완전한 URI를 가진다

### 6.5.2 가상 호스팅에서 일어나는 같은 문제

- 프락시의 ‘스킴/호스트/포트번호 누락’ 문제와 같은 문제가 있음
- 비슷한 문제지만 다른 방법으로 해결
    - 프락시는 요청 메시지가 완전한 URI를 갖도록해서 해결
    - 가상으로 호스팅 되는 웹서버는 호스트와 포트에 대한 정보가 담겨있는 Host 헤더를 요구

### 6.5.3 인터셉트 프락시는 부분 URI를 받는다

- 클라이언트가 자신이 웹서버와 대화하고 있다고 생각하고 완전한 URI를 보내지 않는 경우가 있다

### 6.5.4 프락시는 프락시 요청과 서버 요청을 모두 다룰 수 있다.

- 다목적 프락시 서버의 경우 완전한 URI와 부분 URI 모두 지원해야한다.
- 완전한 URI와 부분 URI를 사용하는 규칙
    - 완전한 URI가 주어진 경우는 완전한 URI 사용
    - 부분 URI가 주어지고 Host 헤더가 있다면 Host 헤더를 이용해 원 서버의 이름과 포트 번호를 알아내야한다
    - Host 헤더가 없는 경우
        - 대리 프락시라면 실제 서버의 주소와 포트 번호가 설정되어 있을 수 있다
        - 인터셉트 프락시가 원 IP주소와 포트번호를 사용할 수 있도록 해두었다면, 그 IP주소와 포트 번호 사용 가능
        - 모두 실패한 경우 에러메시지를 반환

### 6.5.5 전송중 URI변경

- 프락시 서버는 요청 URI 변경에 매우 신경 써야한다
- 사소한 변경이 다운스트림 서버와 상호운용성 문제를 일으킬 수 있기 때문
- http명세에는 인터셉트 프락시가 URI를 전달할 때 절대 경로를 고쳐 쓰는 것을 금지한다
- 예외: 빈경로(’/’)로 교체

### 6.5.6 URI 클라이언트 자동확장과 호스트명 분석

- 브라우저는 프락시의 존재 여부에 따라 요청 URI를 다르게 분석한다
    - 프락시가 없으면 사용자가 타이핑한 URI를 가지고 대응하는 IP주소를 찾는다
    - 호스트명이 발경되면 그에 대응하는 IP주소들을 연결에 성공할 때까지 시도해본다.
    - 호스트가 발견되지 않으면, 많은 브라우저들은 사용자가 호스트명의 짧은 약어를 타이핑한 것으로 본다
    - 확장을 제공하고자 다음과 같이 몇가지 시도를 한다.
        - 웹사이트 이름의 가운데 부분만 입력했다면, 브라우저는 ‘www.’ 접두사를 붙이고 ‘.com’ 접미사를 붙인다
        - 몇몇 브라우저는 서드파티 사이트로 넘기기도 한다
        - dns는 사용자가 호스트 명의 앞부분만 입력하면 자동으로 도메인을 검색하도록 설정되어 있다

### 6.5.7 프락시없는 URI 분석

- 프락시가 없는 경우 브라우저가 호스트명을 자동확장한다.
    
    

### 6.5.8 명시적인 프락시를 사용할 때의 URI 분석

- 프락시를 사용하는 경우 브라우저는 편리한 확장을 수행할 수 없다
- 브라우저가 URI가 프락시를 그냥 지나쳐버리기때문
- 몇몇 프락시는 자동확장이나 지역 도메인 접미사 추가와 같은 서비스를 최대한 흉내내려고 한다.

### 6.5.9 인터셉트 프락시를 이용한 URI 분석

- 인터셉트 프락시와 명시적인 프락시 모두 죽은 서버의 DNS 분석에 대한 장애 허용을 지원해야한다.

## 6.6 메시지 추적

### 6.6.1 Via 헤더

- Via 헤더 필드는 메시지가 지나는 각 중간 노트의 정보를 나열한다.
- 메시지가 또 다른 노드를 지날 때마다, 중간 노드는 Via 목록의 끝에 반드시 추가 되어야한다.
- 프락시는 요청을 보내기 전에 자신을 가리키는 유일한 문자열을 헤더에 삽입해야한다.
- Via 헤더는 프로토콜 변환을 기록한다

## 6.7 프락시 인증

- 프락시는 접근 제어 장치로 제공될 수 있다

## 6.8 프락시 상호운용성

### 6.8.1 지원하지 않는 헤더와 메서드 다루기

- 프락시는 이해할 수 없는 헤더 필드는 반드시 그대로 전달해야한다.
- 같은 이름의 헤더 필드가 여러 개 있는 경우에는 그들의 상대적인 순서도 반드시 유지해야한다.

### 6.8.2 OPTIONS: 어떤 기능을 지원하는지 알아보기

- 서로 다른 기능 수준의 서버와 프락시가 더 쉽게 상호작용할 수 있도록 클라이언트는 OPTIONS를 이용해 서버의 능력을 먼저 알아낼 수 있다.

### 6.8.3 Allow 헤더

- 요청 URI에 의해 식별되는 자원에 대해 지원되는 메서드들이나 서버가 지원하는 모든 메서드를 열거한다
