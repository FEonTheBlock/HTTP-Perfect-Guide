# 7장 캐시

- 웹 캐시: 자주 쓰이는 문서의 사본을 자동으로 보관하는 HTTP 장치
- 캐시의 장점
  - 불필요한 데이터 전송 감소
  - 네트워크 병목 감소
  - 원 서버에 대한 요청 감소, 서버 부하 감소
  - 거리로 인한 지연 감소

## 7.1 불필요한 데이터 전송

- 같은 데이터를 네트워크를 통해 계속 반복 전송하여 불필요한 데이터 전송이 발생
  → 값비싼 네트워크 대역폭 사용, 전송 속도 감소, 웹 서버 부하
- 캐시를 이용하면 첫 번째 서버 응답이 캐시에 보관되어 후속 요청에 대한 응답으로 사용됨.
  → 중복 트래픽 방지

## 7.2 대역폭 병목

- 클라이언트가 서버에 접근할 때의 속도는 그 경로에 있는 가장 느린 네트워크의 속도
- 대역폭은 큰 문서에 대해 현저한 지연을 일으킴
- 캐시가 네트워크 병목을 줄여 줌.

## 7.3 갑작스런 요청 쇄도(Flash Crowds)

- 많은 사람이 동시에 웹 문서에 접근하면 트래픽이 급증하여 네트워크와 웹 서버에 심각한 장애를 야기시킴.
- 캐싱으로 갑작스런 요청 쇄도에 대처할 수 있음.

## 7.4 거리로 인한 지연

- 물리적 거리로 인한 지연을 캐싱으로 줄일 수 있음.

## 7.5 적중과 부적중

- 캐시 적중(cache hit): 캐시에 요청이 도착했을 때 그에 대응하는 사본이 있어 그를 이용해 요청이 처리되는 경우
- 캐시 부적중(cache miss): 캐시 요청에 대응하는 사본이 없어 원 서버로 요청을 전달하는 경우

### 7.5.1 재검사(Revalidation)

- HTTP 재검사: 캐시가 가지고 있는 사본이 여전히 최신인지 점검하는 것
- 대부분의 캐시는 클라이언트가 사본을 요청하였으며 그 사본이 충분히 오래된 경우에 재검사를 함.
- 콘텐츠가 변경되지 않았다면 서버는 304 Not Modified 응답을 보냄.
- 재검사 적중(느린 적중): 재검사에서 사본이 신선하다고 캐시가 판단 후 클라이언트에 제공하는 것
- 재검사 부적중: 서버 객체가 캐시된 사본과 다르면 서버는 콘텐츠 전체와 함께 HTTP 200 OK 응답을 보냄.
- 객체 삭제: 서버 객체가 삭제되었다면 서버는 404 Not Found 응답을 보내고 캐시는 사본을 삭제함.
- GET 요청에 If-Modified-Since 헤더를 추가해 보내면 캐시된 시간 이후 변경된 경우에만 사본을 전송

### 7.5.2 적중률

- 캐시 적중률(캐시 적중비, 문서 적중률, 문서 적중비): 캐시가 요청을 처리하는 비율
- 얼마나 많은 웹 트랜잭션을 외부로 내보내지 않았는지 보여주며, 문서 적중률을 개선하면 전체 대기 시간이 줄어듦.
- 캐시는 유용한 콘텐츠가 캐시 안에 머무르도록 보장하기 위해 노력

### 7.5.3 바이트 적중률

- 바이트 적중률: 캐시를 통해 제공된 모든 바이트의 비율로, 트래픽이 절감된 정도를 포착
- 얼마나 많은 바이트가 인터넷으로 나가지 않았는지 보여주며, 바이트 단위 적중률 개선은 대역폭 절약을 최적화함.

### 7.5.4 적중과 부적중의 구별

- HTTP는 캐시 적중 여부를 클라이언트에게 알리지 않음.
- 클라이언트는 Date 헤더를 이용해 응답 생성일을 현재 시각과 비교하여 캐시 여부를 알아내거나 Age 헤더를 이용하여 응답이 얼마나 오래되었는지 알아낼 수 있음.

## 7.6 캐시 토폴로지

- 개인 전용 캐시(private cache): 한 명의 사용자가 자주 찾는 페이지를 담는 개인만을 위한 캐시
- 공유된 캐시(public cache): 사용자 집단에게 자주 쓰이는 페이지를 담는 공용 캐시

### 7.6.1 개인 전용 캐시

- 웹브라우저에 내장된 개인 전용 캐시는 자주 쓰이는 문서를 개인용 컴퓨터의 디스크와 메모리에 캐시

### 7.6.2 공용 프락시 캐시

- 프락시 캐시는 로컬 캐시에서 문서를 제공하거나 사용자의 입장에서 서버에 접근
- 공용 캐시에는 여러 사용자가 접근하므로 불필요한 트래픽을 줄일 수 있음.

### 7.6.3 프락시 캐시 계층들

- 클라이언트 주위에는 작고 저렴한 캐시를 사용, 계층 상단에는 많은 사용자에 의해 공유되는 문서를 유지하기 위해 더 크고 강력한 캐시를 사용
- 캐시 계층이 깊어 프락시 연쇄가 길어지면 각 중간 프락시는 현저한 성능 저하가 발생함.

### 7.6.4 캐시망, 콘텐츠 라우팅, 피어링

- 몇몇 네트워크 아키텍처는 단순한 캐시 계층 대신 복잡한 캐시망을 만들어 캐시 커뮤니케이션 결정을 동적으로 내림.

## 7.7 캐시 처리 단계

### 7.7.1 단계 1: 요청 받기

- 캐시가 네트워크로부터 도착한 메시지를 읽어들임.
- 고성능 캐시는 여러 커낵션으로부터 데이터를 동시에 읽어들이고 메시지 전체가 도착하기 전에 트랜잭션 처리를 시작함.

### 7.7.2 단계 2: 파싱

- 캐시는 요청 메시지를 여러 부분으로 파싱하여 URL과 헤더를 추출, 헤더 부분을 조작하기 쉬운 자료 구조에 담으.

### 7.7.3 단계 3: 검색

- 캐시는 URL을 알아내 로컬 복사본이 있는지 검사하고, 사본이 없다면 사본을 받아온 후 로컬에 저장함.

### 7.7.4 단계 4: 신선도 검사

- 캐시된 사본이 신선한지 검사하고, 신선하지 않다면 변경사항이 있는지 재검사

### 7.7.5 단계 5: 응답 생성

- 캐시된 서버 응답 헤더를 토대로 응답 헤더를 생성

### 7.7.5 단계 6: 전송

- 캐시가 응답을 클라이언트에게 돌려줌.

### 7.7.7 단계 7: 로깅

- 대부분의 캐시가 로그 파일과 캐시 사용에 대한 통계를 유지함.

## 7.8 사본을 신선하게 유지하기

- 문서 만료와 서버 재검사: 어떤 캐시가 사본을 갖고 있는지 서버가 기억하지 않더라도 캐시된 사본이 서버와 충분히 일치하도록 유지할 수 있게 해 주는 HTTP의 메커니즘

### 7.8.1 문서 만료

- HTTP는 Cache-Control, Expires와 같은 헤더를 이용하여 원 서버가 각 문서에 유효기간을 붙일 수 있게 해 줌.

### 7.8.2 유효기간과 나이

- 서버는 응답 본문과 함께 하는 HTTP/1.0+ Expires, HTTP/1.1 Cache-Control: max-age 응답 헤더를 이용해 유효기간을 명시

### 7.8.3 서버 재검사

- 서버 재검사: 캐시가 원 서버에게 문서가 변경되었는지의 여부를 물어보는 것

### 7.8.4 조건부 메서드와의 재검사

- 캐시가 서버에게 조건부 GET 요청을 보내어 서버가 갖고 있는 문서가 캐시가 갖고 있는 것과 다른 경우에만 객체 본문을 요청할 수 있음.

### 7.8.5 If-Modified-Since(IMS): 날짜 재검사

- 서버에게 리소스가 특정 날짜 이후로 변경된 경우에만 요청한 경우에만 요청한 본문을 보내달라는 헤더
- 문서가 주어진 날짜 이후 변경되었다면 IMS 조건이 참이므로 GET 요청은 성공, 새로운 만료 날짜가 담긴 헤더와 함께 캐시에 반환
- 주어진 날짜 이후 문서 변경이 없다면 IMS 조건이 거짓이므로 304 Not Modified 응답 메시지를 돌려줌.

### 7.8.6 If-None-Match: 엔터티 태그 재검사

- 퍼블리셔가 문서를 변경할 때 문서의 엔터티 태그를 새로운 버전으로 표현하고, 엔터티 태그 변경 시 새 문서의 사본을 얻음.
- 변경 시각이 바뀌었지만 내용에 변화가 없는 경우, 사소한 변경일 경우 등에 사용

### 7.8.7 약한 검사기와 강한 검사기

- HTTP/1.1은 콘텐츠가 조금 변경되었어도 문서를 같은 것으로 판단하는 약한 검사기를 지원, W/ 접두사로 약한 검사기를 구분함.
- 강한 검사기는 엔터티 값이 어떻게 바뀌든 강한 엔터티 태그가 매번 바뀌어 콘텐츠가 바뀔 때매다 바뀜.

### 7.8.8 언제 엔터티 태그를 사용하고 언제 Last-Modified 일시를 사용하는가

- HTTP/1.1 클라이언트는 서버가 엔터티 태그를 반환했다면 반드시 엔터티 태그 검사기를 사용해야 함.
- HTTP/1.1 캐시나 서버가 IMS와 엔터티 태그 조건부 헤더를 모두 받았다면 요청의 모든 조건부 헤더 필드의 조건에 부합하지 않는 한 304 Not Modified 응답을 반환하면 안 됨.
