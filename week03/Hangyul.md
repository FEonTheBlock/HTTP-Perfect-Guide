# 2022년 3월 5일 한결 공부내용

## 4장 커넥션 관리

### 1. TCP 커넥션

- HTTP 통신은 TCP/IP를 통해 이루어진다.
    - HTTP 커넥션 = TCP 커넥션 + 몇몇 사용 규칙
    - TCP/IP: 패킷 교환 네트워크 프로토콜, 손상이나 유실 없이 안전하게 전달
    - HTTPS는 HTTP와 TCP 사이에 보안(암호화) 계층이 한 겹 추가된 것
- TCP: 신뢰할 수 있는 데이터 전송 통로
    - 세그먼트 단위로 데이터 스트림을 나누고, IP 패킷에 담아 전달
    - 포트 번호를 통해 여러 개의 커넥션 유지
    - <발신자 IP 주소, 발신자 포트, 수신자 IP 주소, 수신자 포트> 로 식별
    - TCP 소켓 프로그래밍: 소켓 API를 사용한 TCP 프로그래밍
- IP 패킷 =  IP 패킷 헤더(20바이트) + TCP 세그먼트 헤더(20바이트) + TCP 데이터 조각
    - IP 헤더: 발신지와 목적지 IP주소, 크기, 기타 플래그
    - TCP 세그먼트 헤더: TCP 포트 번호, TCP 제어 플래그, 데이터의 순서, 무결성 검사 코드 등을 포함

### 2. TCP의 성능에 대한 고려

- 작업 처리 시간은 TCP 커넥션을 설정하고, 요청을 전송하고, 응답을 받는 것에 비하면 상당히 짧다.
    - 대부분의 HTTP 지연은 TCP 네트워크 지연으로 발생하는데, 그 이유는 아래의 요인들 때문
        - 방문한 적 없는 호스트의 경우 DNS로 URI의 호스트이름을 IP로 변환하는데 시간 소요
        - 커넥션 요청을 보내고 응답을 받는 과정에서 수백개의 HTTP 트랜잭션이 있는 경우
        - 커넥션 연결 후 HTTP 요청을 전달하는 것에 시간 소요
        - 웹서버가 HTTP 응답을 보내는 것에 시간 소요
    - 하드웨어 성능, 네트워크나 서버의 전송 속도, 메시지 크기, 클라이언트와 서버간 거리 등에도 영향
- 일반적인 TCP 관련 지연들
    - TCP 커넥션 핸드셰이크 지연
        - 커넥션을 맺기 위한 IP 패킷 교환: 커넥션 생성 요청(SYN 플래그) 패킷 전송 → 서버가 수락하면 TCP 패킷(SYN, ACK 플래그)을 전송 → 커넥션이 잘 맺어졌다는 확인응답 신호 전송
        - 트랜잭션 이전에 위의 프로세스가 이루어지는데, 작은 크기의 트랜잭션이라면 배보다 배꼽이 더 큰 상황이 된다.
        - ⇒ 이러한 지연을 제거하기 위해 HTTP는 이미 존재하는 커넥션을 재활용
    - 확인응답 지연
        - TCP는 성공적인 데이터 전송을 보장하기 위한 자체적 확인 체계(순번과 무결성 체크섬)를 갖는다.
        - 수신자는 세그먼트를 온전히 받으면 작은 확인응답 패킷을 송신자에게 반환
        - 송신자가 특정시간 안에 확인응답 메시지를 받지 못하면 오류상황으로 판단하고 데이터 재전송
        - 확인응답은 효율적 네트워크 사용을 위해 같은 방향으로 송출되는 데이터 패킷에 묶여서 갈 수 있는데, 이런 경우를 늘리기 위해 확인응답 지연 알고리즘으로 확인응답을 버퍼에 저장해 둔 후 송출되는 데이터 패킷을 찾은 후 전송한다. (찾지 못하면 확인응답만 전송)
        - ⇒ HTTP 동작 방식에서는 확인 응답이 묶여서 가능 경우가 적고, 이를 찾는 과정에서 지연이 발생하므로 확인응답 지연 기능을 수정하거나 비활성화하여 지연을 막을 수 있다.
    - TCP 느린 시작 (Slow start)
        - TCP 커넥션은 인터넷의 급작스러운 부하와 혼잡을 막기 위해 만들어진 직후에는 한 번에 전송할 수 있는 패킷 수를 제한함으로써 최대 속도를 제한한다.
        - 데이터가 성공적으로 전송되면 추가로 두개의 패킷을 더 전송할 수 있는 권한을 얻으며, 속도 제한이 풀린다. (혼잡 윈도우가 열린 ‘튜닝’된 커넥션이 된다.)
        - ⇒ 새로 맺어진 커넥션보다 어느정도 데이터를 주고받은 커넥션이 더 빠르므로 HTTP는 이를 재사용하는 기능을 활용한다(지속 커넥션).
    - 네이글(Nagle) 알고리즘과 TCP_NODELAY
        - 각 TCP 세그먼트는 데이터 크기에 상관없이 40바이트 상당의 플래그, 헤더 포함
        - 네이글 알고리즘은 네트워크 효율을 위해 패킷을 전송하기 전 많은 양의 TCP 데이터를 한 개의 덩어리로 합친다.
        - 세그먼트가 최대 크기가 되지 않으면 전송하지 않는다. (다른 모든 패킷이 확인 응답을 받은 경우에만 전송)
        - 다른 패킷들이 전송 중이면 데이터는 버퍼에 저장되고, 확인응답을 받거나 최대 크기가 되었을 때 저장되어있던 데이터 전송
        - 크기가 작은 HTTP 메시지는 항상 지연되며, 확인응답 지연과 함께 쓰이면 서로 지연 대파티
        - ⇒ HTTP 스택에 TCP_NODELAY 파라미터 값을 설정하여 네이글 알고리즘 비활성화 
        (그러나 이 경우 작은 크기 패킷이 너무 많이 생기지 않도록 큰 데이터 덩어리 만들어줄 것?)
    - TIME_WAIT의 누적과 포트 고갈
        - 이전 커넥션과 관련된 패킷이 새로운 커넥션에 삽입되는 문제를 방지하기 위해 TCP 커넥션이 끊긴 후 같은 주소와 포트번호를 사용하는 새로운 커넥션이 일정시간(보통 2분) 동안에는 생성되지 않도록 하는데, 현대에는 이런 문제들이 거의 없다.
        - 일반적으로 커넥션 종료 지연이 문제되지는 않지만 성능 측정 시 문제

### 3. 커넥션 관리

- HTTP 커넥션 생성 및 관리에서 매우 중요한 HTTP 커넥션 헤더, 그리고 최적화 기술에 대해 알아보자.
- Connection 헤더
    - HTTP 메시지는 클라이언트 → 서버 사이 중개 서버들을 거치며 전달되는데, 현재 맺고 있는 커넥션에서만 적용될 옵션을 지정해야 하는 경우가 있다.
    - 커넥션 토큰들 : HTTP 헤더 필드 이름(이 커넥션에만 해당하는 헤더), 임시 토큰 값, close 값(커넥션 작업 완료 후 종료 여부)
    - 커넥션 토큰이 HTTP 헤더 필드 이름을 가질 때, 현재 커넥션만을 위한 정보이므로 다음 커넥션에 전달하면 안되고, 모두 삭제되어야 한다.
- 순차적인 트랜잭션 처리에 의한 지연
    - 한 페이지를 위한 트랜잭션이 여러개인 경우, 각 트랜잭션이 새로운 커넥션을 필요로 하면 지연(느린 시작 지연 등) 발생
    - 데이터 로드하기 전까지 유저의 심리적 지연이 발생, 특히 객체의 크기를 알아야 화면에 배치할 수 있는 경우 모든 객체를 내려받기 전까지는 빈 화면만.
    - ⇒ 병렬 커넥션(동시 HTTP 요청), 지속 커넥션(TCP 커넥션 재활용), 파이프라인 커넥션, 다중 커넥션

### 4. 병렬 커넥션

- 첨부된 객체를 하나씩 내려받는 경우 너무 느리기 때문에 여러 개의 커넥션으로 HTTP 트랜잭션을 병렬처리
- 각 커넥션의 지연 시간을 겹치게 하고, 남은 대역폭을 여러 커넥션이 사용
- 대역폭이 좁은 경우 성능상의 장점이 거의 없어지며, 다수의 커넥션은 메모리를 많이 소모하고 자체적인 성능 문제를 발생시키므로 브라우저는 적은 수(4개)의 병렬 커넥션만을 허용
- 화면에 여러 개의 객체가 동시에 보이기 때문에 심리적으로 더 빠르게 느껴진다.

### 5. 지속 커넥션

- 보통 웹 클라이언트는 같은 사이트에 여러 개의 커넥션을 맺는다. 같은 서버에 또 요청을 하는 경향(사이트 지역성, site locality)을 갖는다.
- HTTP 1.1에서는 처리가 완료된 후에도 클라이언트나 서버가 끊기 전까지 TCP 커넥션을 유지, 앞으로 있을 HTTP 요청에 재사용한다.
- 커넥션 준비 작업에 따르는 시간을 절약하고 튜닝된 커넥션을 계속 사용하며 느린 시작 지연을 피할 수 있다.
- 커넥션을 맺기 위한 사전 작업과 지연을 줄이고, 튜닝 커넥션을 유지하며, 커넥션 수도 줄여주므로 병렬 커넥션에 비해 장점이 있지만 잘못 관리할 경우 계속 연결된 상태의 수많은 커넥션이 쌓여 불필요한 리소스 소모
→ 병렬 커넥션과 함께 사용할 때 가장 효과적: 적은 수의 병렬 커넥션을 맺고 이를 유지하는 방식으로 다음과 같은 두 가지의 지속 커넥션 타입이 많이 사용된다.
    - HTTP/1.0+의 `keep-alive` 커넥션
        - 커넥션을 맺고 끊는 데 필요한 작업이 없어 시간이 단축
        - HTTP/1.1 명세에서는 빠졌지만 keep-alive 핸드셰이크가 아직 널리 사용되고 있다.
        - 클라이언트는 커넥션을 유지하기 위해 요청에 `Connection: Keep-Alive` 헤더를 포함시키며, 서버 또한 다음 요청을 이 커넥션을 통해 받기 위해서는 응답 메시지에 같은 헤더를 포함 시킨다. 
        → 위 헤더가 없는 요청을 받으면 서버는 요청을 처리한 후 커넥션을 끊는다.
        → 위 헤더가 없는 응답을 받으면 클라이언트는 서버가 응답 후 커넥션을 끊을 것임을 알 수 있다.
        - 요청을 받았다고 해서 무조건 따를 필요는 없으며, 얼마간 유지될 것인지(`timeout`), 몇 개의 트랜잭션을 처리할 때까지 유지될 것인지(`max`) 등을 파라미터로 명시할 수 있지만 이대로 동작한다는 보장은 없다.
    - HTTP/1.1의 지속 커넥션
        - keep-alive 커넥션을 지원하지 않지만 더 잘 동작하는 지속 커넥션을 지원한다.
        - 기본으로 모든 커넥션을 지속 커넥션 취급, 커넥션을 끊으려면 `Connection: close` 헤더를 명시
        → 위 헤더가 없는 요청을 보냈다면 클라이언트는 그 커넥션으로 추가적 요청을 보낼 수 없다.

### 6. 파이프라인 커넥션

### 7. 커넥션 끊기에 대한 미스테리