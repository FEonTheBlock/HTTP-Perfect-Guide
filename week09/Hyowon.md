# 10장 HTTP/2.0
## 10.1 HTTP/2.0의 등장 배경

- HTTP/1.1의 메시지 포맷은 구현의 단순성과 접근성에 주안점을 두고 최적화되었다.
- 그러다 보니 성능은 어느정도 희생시키게되었다.
- 커넥션 하나를 통해 요청 하나를 보내고 그에 대해 응답 하나만을 받는 HTTP의 메시지 교환방식은 단순하지만 응답을 받아야만 다음 요청을 보낼 수 있기때문에 심각한 회전 지연(latency)를 피할 수 없었다
    - 이 문제를 회피하기 위해 병렬 커넥션이나 파이프라인 커넥션이 도입되었지만 성능 개선에 대한 근본적인 해결책은 되지 못했다
- HTTP/1.1 의 성능 문제를 해결하고자 많은 노력이 있었다
    - 로이 필딩 - WAKA 프로토콜
    - Microsoft -  S+M 프로토콜
    - 구글 - SPDY 프로토콜
        - 헤더를 압축하여 대역폭 절약
        - 하나의 TCP 커넥션에 여러 요청을 동시에 보내 latency 를 줄임
        - 클라이언트가 요청을 보내지 않아도 서버가 능동적으로 리소스를 푸시하는 기능
        - 이 프로토콜을 기반으로 HTTP/2.0이 설계됨

## 10.2 개요

- HTTP/2.0은 서버와 클라이언트 사이의 TCP 커넥션 위에서 동작한다.
    - 이때 TCP 커넥션을 초기화하는 것은 클라이언트다
- HTTP/2.0 요청과 응답은 길이가 정의된(최대 16383바이트) 한 개 이상의 프레임에 담긴다. 이때 HTTP 헤더는 압축되어 담긴다
- 프레임들에 담긴 요청과 응답은 스트림을 통해 보내진다
- 한 개의 스트림이 한쌍의 요청과 응답을 처리한다.
- 하나의 커넥션 위에 여러개의 스트림이 동시에 만들어 질 수 있음
    - 여러 개의 요청과 응답을 동시에 처리하는 것이 가능
- HTTP/2.0은 스트림에 대한 흐름 제어와 우선순위 부여 기능도 제공한다.
    - 기존 요청-응답과 다른 `서버푸시`를 도입
- 기존 요청-응답과 다르게 `서버푸시` 를 도입
    - 서버는 클라이언트에게 필요하다고 생각하는 리소스라면 능동적으로 클라이언트에게 보낼 수 있다.
- 기존 웹 어플리케이션들과 호환성을 유지하기 위해 요청과 응답 메시지의 의미를 HTTP/1.1과 같도록 유지하고있다.
    - Content-Length 헤더는 본문의 길이를 의미하지만 문법은 변경되었다. →  `:content-length`
    

## 10.3 HTTP/1.1과의 차이점

### 10.3.1 프레임

- HTTP/2.0에서 모든 메시지는 프레임에 담겨 전송된다.
- 모든 프레임은 8바이트 크기의 헤더로 시작하며, 최대 16383바이트 크기의 페이로드가 온다.
- DATA, HEADERS, PRIORITY, RST_STREAM, SETTINGS, PUSH_

PROMISE, PING, GOAWAY, WINDOW_UPDATE, CONTINUATION이라는 총 10가지 프레임을 정의하고 있으며, 페이로드의 형식이나 내용은 프레임의 종류에 따라 다르다

### 10.3.2 스트림과 멀티플렉싱

- 스트림은 HTTP/2.0 커넥션을 통해 클라이언트와 서버 사이에서 교환되는 프레임들의 독립된 양방향 시퀀스다.
- 한 쌍의 HTTP 요청과 응답은 하나의 스트림을 통해 이루어진다
    - 클라이언트는 새 스트림을 만들어 HTTP 요청을 보낸다
    - 요청을 받은 서버는 그 요청과 같은 스크림으로 응답을 보낸다
    - 그러고 나면 스트림이 닫히게 된다.
- HTTP/1.1에서는 한 TCP커넥션을 통해 요청을 보냈을 때, 그에 대한 응답이 도착하고 나서야 같은 TCP 커넥션으로 다시 요청을 보낼 수 있다.
    - 웹 브라우저들은 회전 지연을 줄이기 위해 여러 개의 TCP 커넥션을 만들어 동시에 여러 개의 요청을 보내는 방법을 사용한다.
    - TCP 커넥션을 무한정 만들 수는 없고, 오늘날에는 요청이 수십에서 수백에 달하기때문에 회전지연이 늘어나는 것을 피하기는 어렵다.
- HTTP/2.0에서는 하나의 커넥션에 여러 개의 스트림이 동시에 열릴 수 있다
    - 하나의 커넥션을 통해 여러 개의 요청이 동시에 보내질 수 있기때문에 이 문제는(회전지연) 쉽게 해결될 수 있다.
- 스트림은 우선순위도 가질 수 있다.
    - 하지만 요청이 우선순위대로 처리된다는 보장은 없음
- 스트림은 31비트의 무부호 정수로 된 고유한 식별자를 갖는다
    - 스트림이 클라이언트에 의해 초기화되었다면 식별자는 만드시 홀수, 서버라면 짝수
    - 새로 만들어지는 스트림의 식별자는 이전에 만들어졌거나 예약된 스트림들의 식별자보다 커야한다.
    - 규칙을 어기면 에러코드가 PROTOCOL_ERROR인 커넥션 에러로 응답
- 서버와 클라이언트는 스트림을 상대방과 협상 없이 일방적으로 만든다
    - 협상을 위해 TCP 패킷을 주고 받느라 시간을 낭비하지 않아도 된다.
- 커넥션에서 한번 사용한 스트림 식별자는 다시 사용할 수 없다.
    - 식별자가 고갈되는 경우 커넥션을 다시 맺으면 된다.
- 동시에 여러개의 스트림을 사용하면 스트림이 블록될 우려가 있다는 주징이 있다
    - HTTP/2.0은 WINDOW_UPDATE 프레임을 이용한 흐름 제어를 통해, 스트림들이 서로 간섭해서 망가지는 것을 막아준다
    

### 10.3.3 헤더압축

- HTTP/1.1에서 헤더는 아무런 압축 없이 그대로 전송되었다.
- 과거의 웹페이지는 요청이 많지 않았기 때문에 헤더의 크기가 큰 문제가 되지 않았지만 요즘에는 요청이 많아졌기때문에 헤더의 크기가 회전 지연과 대역폭 양쪽 모두에 실질적인 영향을 끼치게 되었다.
- HTTP/2.0에서는 HTTP 메시지의 헤더를 압축하여 전송한다.
    - 헤더는 HPACK 명세에 정의된 헤더 압축 방법으로 압축된 뒤 `헤더 블록 조각`로 쪼개져서 전송된다.
    - 받는 쪽에서는 이 조각들을 이은 뒤 압축을 풀어 원래의 헤더 집합으로 복원한다.
    - 헤더를 압축하고 해제할 때 `압축 콘텍스트`를 사용한다.
        - 오동작하지 않으려면 항상 올바른 압축 콘텍스트를 유지해야한다.
        - 수신한 헤더의 압축을 풀면 이에 영향을 받아 바뀐다.
        - 송신 측은 수신측이 헤더의 압축을 풀었으며 그에 따라 압축 콘텍스트가 변경되었다고 가정할 것이다.
        - 따라서 수신측은 헤더를 사용하지 않는 경우에도 반드시 압축 해제를 해야한다.
        - 그럴 수 없다면 반드시 COMPRESSION_ERROR와 함께 커넥션을 끊어야한다.

### 10.3.4 서버 푸시

- HTTP/2.0은 서버가 하나의 요청에 대해 응답으로 여러 개의 리소스를 보낼 수 있도록 해준다.
- 이 기능은 서버가 클라이언트에서 어떤 리소스를 요구할 것인지 미리 알 수 있는 상황에서 유용하다.
    - HTML 문서를 요청 받은 서버는 그 문서가 링크하고 있는 이미지, CSS파일, 자바스크립트 파일 등의 리소스를 클라이언트에게 푸시할 수 있을 것이다.
    - 이는 클라이언트가 HTML 문서를 파싱해서 필요한 리소스를 다시 요청하여 발생하는 트래픽과 회전 지연을 줄여준다.
- 리소스를 푸시하려는 서버는 먼저 클라이언트에게 자원을 푸시 할 것임을 PUSH_PROMISE 프레임을 보내어 미리 알려주어야 한다.
    - 클라이언트가 PUSH_PROMIS 프레임을 받게 되면 해당 프레임의 스트림은 클라이언트 입장에서는 `예약됨` 상태가 된다.
    - 클라이언트는 RST_STREAM 프레임을 보내서 푸시를 거절할 수 있고, 스트림은 즉각 닫히게 된다.
    - 스트림이 닫히기 전까지는 클라이언트는 서버가 푸시하려고 하는 리소스를 요청해서는 안 된다.
    - PUSH_PROMISE 프레임을 보내는 이유는 서버가 푸시하려고 하는 자원을 클라이언트가 또 요청하는 상황을 피하기 위해서이다.
- 서버 푸시를 사용할 때 주의할 점
    - 서버 푸시를 사용하기로 했더라도 프락시가 클라이언트에게 전달하지 않을 수 있고 반대로 추가 리소스를 서버에게 받지 않았어도 클라이언트에게 추가 리소스를 전달 할 수 있다.
    - 서버는 안전하고, 캐시가능하고, 본문을 포함하지 않은 요청에 대해서만 푸시를 할 수 있다.
    - 푸시할 리소스는 클라이언트가 명시적으로 보낸 요청과 연관된 것이어야 한다.
    - 클라이언트는 서버가 푸시한 리소스를 동일출처정책에 따라 검사해야한다.
    - 서버푸시를 끄고 싶다면 SETTINGS_ENABLE_PUSH를 0으로 설정하면 된다.

## 10.4 알려진 보안 이슈

### 10.4.1 중개자 캡슐화 공격

HTTP/2.0 메시지를 중간의 프락시가 HTTP/1.1 메시지로 변환할 때 메시지의 의미가 변질될 가능성이 있다.

### 10.4.2 긴 커넥션 유지로 인한 개인정보 누출 우려

# 11장 클라이언트 식별과 쿠키

## 11.1 개별 접촉

- HTTP는 익명으로 사용하며 상태가 없다
- 웹 서버는 요청을 보낸 사용자를 식별하거나 방문자가 보낸 연속적인 요청을 추적하기 위해 약간의 정보를 이용할 수 있다.
- 현대의 웹 사이트들은 개인화된 서비스를 제공하고 싶어 한다.
    - 개별 인사
    - 사용자 맞춤 추천
    - 저장된 사용자 정보
    - 세션 추적
    

## 11.2 HTTP 헤더

- 사용자에 대한 정보를 전달하는 가장 일반적인 HTTP요청 헤더
    - From 헤더: 사용자의 이메일 주소를 포함한다
        - 악의적인 서버가 이메일 주소를 모아서 스팸 메일을 발송하는 문제가 있어서 From 헤더를 보내는 브라우저는 많지 않다.
    - User-Agent 헤더: 사용자가 쓰고 있는 브라우저의 이름과 버전 정보, 경우에 따라 운영체제에 대한 정보까지 포함하여 서버에게 알려준다.
    - Referer 헤더: 사용자가 현재 페이지로 유입하게 한 웹페이지의 URL을 가리킨다.
    - From, User-Agent, Referer 헤더들은 확실히 식별하기에는 부족한 정보를 가진다.

## 11.3 클라이언트 IP주소

- 초기에는 사용자 식별에 IP주소를 사용하려고 함
- 이 방식은 사용자가 확실한 IP주소를 가지고 있고, 그 주소가 좀처럼 바뀌지 않고, 웹 서버가 요청마다 클라이언트의 IP를 알 수 있다면 문제없이 동작한다.
- 클라이언트 IP주소는 보통 HTTP헤더에 없지만, 웹서버는 HTTP요청을 보내는 반대쪽 TCP 커넥션의 IP 주소를 알아낼 수 있다.
- 클라이언트 IP주소로 사용자를 식별하는 방식의 약점
    - 클라이언트 IP주소는 사용자가 아닌 사용하는 컴퓨터를 가리킨다. 여러 사용자가 같은 컴퓨터를 사용하는 경우 식별 불가능
    - 많은 인터넷 서비스 제공자는 사용자가 로그인하면 동적으로 IP주소를 할당한다.
    - NAT를 사용하는 경우 실제 IP주소를 방화벽 뒤로 숨기고 방화벽IP주소로 변환한다.
    - HTTP 프락시와 게이트웨이는 원 서버에 새로운 TCP 연결을 한다. 웹서버는 클라이언트의 IP 주소 대신 프락시 서버의 IP주소를 본다.
 
## 11.4 사용자 로그인

- IP주소로 사용자를 식별하는 대신 웹 서버는 사용자 이름과 비밀번호로 인증할 것을 요구해서 사용자에게 명시적으로 식별 요청을 할 수 있다.
- 웹 사이트 로그인이 더 쉽도록 HTTP는 WWW-Authenticate와 Authorization헤더를 사용해 웹 사이트에 사용자 이름을 전달하는 자체적인 체계를 가지고 있다.
- 한번 로그인하면, 브라우저는 사이트로 보내는 모든 요청에 이 로그인 정보를 함께 보내므로 웹 서버는 그 로그인 정보는 항상 확인할 수 있다.

## 11.5 뚱뚱한 URL

- 어떤 웹 사이트는 사용자의 URL마다 버전을 기술하여 사용자를 식별하고 추적하였다.
- 사용자의 상태 정보를 포함하고 있는 URL을 뚱뚱한 URL이라고 한다.
- 뚱뚱한 URL은 다음과 같은 문제가 있다
    - 못생긴 URL
        - 사용자에게 혼란을 준다
    - 공유하지 못하는 URL
        - URL을 공유하게 되면 개인정보까지 공유하게 되는 것
    - 캐시를 사용할 수 없음
    - 서버 부하 가중
    - 이탈
    - 세션 간 지속성의 부재
    

## 11.6 쿠키

- 쿠키는 사용자를 식별하고 세션을 유지하는 방식 중에서 가장 널리 사용하는 방식이다.

### 11.6.1 쿠키의 타입

- 쿠키는 크게 세션 쿠키와 지속 쿠키로 나눌 수있다.
    - 세션 쿠키는 사용자가 사이트를 탐색할 때, 관련한 설정과 선호 사항들을 저장하는 임시 쿠키다.
    - 세션 쿠키는 사용자가 브라우저를 닫으면 삭제된다.
    - 지속 쿠키는 디스크에 저장되어, 브라우저를 닫거나 컴퓨터를 재시작하더라도 남아있다.

### 11.6.2 쿠키는 어떻게 동작하는가

- 쿠키는 서버가 사용자에게 “안녕, 내이름은..” 라고 적어서 붙이는 스티커와 같다.
- 사용자가 웹 사이트에 방문하면, 웹 사이트는 서버가 사용자에게 붙은 모든 스티커를 읽을 수 있다.
- 처음에 사용자가 웹 사이트에 방문하면 웹 서버는 사용자에 대해서 아무것도 모른다.
- 웹 서버는 사용자가 다시 돌아왔을 때, 해당 사용자를 식별하기 위한 유일한 값을 쿠키에 할당한다.
- 쿠키는 임의의 이름=값 형태의 리스트를 가지고, 그 리스트는 Set-Cookie 혹은 Set-Cookie2(확장 헤더) 같은 HTTP응답 헤더에 기술되어 사용자에게 전달한다.

### 11.6.3 쿠키상자: 클라이언트 측 상태

- 쿠키는 기본적으로 브라우저가 서버 관련 정보를 저장하고, 사용자가 해당 서버에 접근할 때마다 그 정보를 함께 전송하게 하는 것이다.
- 브라우저는 크키 정보를 저장할 책임이 있는데, 이 시스템을 ‘클라이언트 측 상태’라고 한다.
- 브라우저는 각기 다른 방식으로 쿠키를 저장한다.

### 11.6.4 사이트마다 각기 다른 쿠키들

- 브라우저는 수백 수천 개의 쿠키를 가지고 있을 수 있지만, 그렇다고 브라우저가 쿠키 전부를 모든 사이트에 보내지는 않는다.
- 브라우저는 보통 각 사이트에 두 개 혹은 세개의 쿠키만을 보낸다.
    - 쿠키를 모두 전달하면 성능이 크게 저하된다
    - 서버에 특화된 이름/값 쌍을 포함하고 있기 때문에, 대부분 사이트에서는 인식하지 않는 무의미한 값
    - 잠재적인 개인정보 문제
- 쿠키 Domain 속성
    - 서버는 쿠키를 생성할 때 Set-Cookie 응답 헤더에 Domain 속성을 기술해서 어떤 사이트가 그 쿠키를 읽을 수 있는지 제어할 수 있다.
- 쿠키 Path 속성
    - 웹 사이트 일부에만 쿠키를 적용할 수 도 있다.
