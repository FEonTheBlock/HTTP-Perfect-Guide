## 들어가며

HTTP 완벽 가이드 3장을 정리한다.

- 메세지가 어떻게 흘러가는가
- HTTP 메세지의 세 부분(시작줄, 헤더, 개체 본문)
- 요청과 응답 메시지의 차이
- 요청 메시지가 반환하는 여러 상태 코드들
- 여러 HTTP 헤더들은 무슨 일을 하는가

## 3장 HTTP 메시지

> HTTP 애플리케이션 간에 주고받은 데이터의 블록

### 3.1 메시지의 흐름

클라이언트, 서버, 프락시 사이를 흐르며 트랜잭션의 방향에 따라 '인바운드', '아웃바운드', 수신 방향에 따라 '업스트림(발송자)', '다운스트림(수신자)'으로 불린다.

#### 3.1.1 메시지는 원 서버 방향을 인바운드로 하여 송신된다

> 트랜잭션 방향에 따라 인바운드(클->서버), 아웃바운드(서버->클)로 불린다.

#### 3.1.2 다운스트림으로 흐르는 메시지

> 응답, 요청 관계없이 모든 메세지는 다운스트림으로 흐른다.

### 3.2 메시지의 각 부분

- 시작줄 : 어떤 메세지인지 서술 (ASCII 13)
  - HTTP/ 1.0 200 OK
- 헤더 : 속성 (ASCII 13, CRLF)
  - Content-type: text/plain
  - Content-length: 19
- 본문 : 데이터
  - Hi! I/m a message!

시작줄과 헤더는 캐리지 리턴(CRLF)로 개행되어있다. (하지만 그냥 개행 문자도 받아들일 수 있는 애플리케이션이어야 함)

본문은 선택적인 데이터 덩어리로, 텍스트, 이진데이터 등을 포함하며 비어있을 수도 있다.

#### 3.2.1 메시지 문법

요청과 응답은 형식이 갑지만 시작줄 문법이 다르다.

- 요청
  <메서드> <요청 URL> <버전>
  <헤더>

  <엔터티 본문>

- 응답
  <버전> <상태 코드> <사유 구절>
  <헤더>

  <엔터티 본문>

*메서드: 클라이언트 측에서 서버가 리소스에 대해 수행해주길 바라는 동작(GET, POST,...)
*요청 URL: 생략된 호스트/포트는 자신을 가리킨다.
*상태코드: 요청 중에 무엇이 일어났는지 설명하는 세 자리 숫자.
*사유구절: 사람에게 읽히기 위한 목적으로 존재 \*헤더들: 이름,콜론(:), 선택적인 공백, 값, CRLF. 본문이 없더라도 헤더의 마지막 줄은 반드시 띄워야 한다.

#### 3.2.2 시작줄

> 무엇을 해야 하는가

- 요청줄(GET /specials/saw-blade.gif HTTP/1)
  - 메서드 /요청URL 버전
- 응답줄(HTTP/1. 0 2ØØ OK)

  - 버전 상태코드 사유 구절

- 메서드
  - GET, HEAD, POST, PIT, TRACE, OPTIONS, DELETE
  - 확장 메서드
- 상태 코드
  |전체범위|정의된 범위|분류|
  |------|---|---|
  |100-199|100-101|정보|
  |200-299|200-206|성공|
  |300-399|300-305|리다이렉션|
  |400-499|400-415|클라이언트 에러|
  |500-599|500-505|서버 에러|

#### 3.2.3 헤더

시작줄 다음 0개, 1개, 혹은 여러 개의 HTTP헤더가 온다. 요청과 응답 메세지의 추가 정보를 더하는 이름/값 쌍의 목록이다.

일반 헤더, 요청 헤더, 응답 헤더, Entity 헤더, 확장 헤더가 있다.

#### 3.2.4 엔터티 본문

선택적으로 필요에 따라 보내야할 내용을 담는 부분이다.

#### 3.2.5 버전 0.9 메시지

HTTP 프로토콜의 초기 버전으로 상태 코드, 사유 구정, 헤더가 없다. 혹 이 버전을 사용한다면 많은 제약이 있다.

### 3.3 메서드

서버에 따라 제한 사항, 사용 가능한 메서드 등이 다르다.

#### 3.3.1 안전한 메서드

요청의 결과로 서버에 아무런 일이 일어나지 않는 메서드 (GET, HEAD 등)

#### 메서드

- GET
- HEAD
- PUT
- POST
- OPTIONS
- DELETE

#### 확장 메서드

HTTP 명세에 정의되지 않은 확장 메서드로 개발자가 직접 정의할 수 있다.

### 3.4 상태 코드

### 3.5 헤더

- 일반 헤더 (클,서버)
  - 서버와 클라이언트 모두에 다양한 목적으로 사용됨(Date...)
- 요청 헤더
  - 클라이언트가 요청할 때에 대한 정보(받고자 하는 데이터 타입 등 Accept: _/_)
- 응답 헤더
  - 클라이언트에게 정보를 제공하기 위한 자신만의 헤더(클라이언트가 어떤 종류의 서버와 대화하고 있는가)
- 엔터티 헤더
  - 엔터티 본문에 대한 헤더(데이터 타입 등 Content-Type: text/html;)
- 확장 헤더
  - 아직 승인된 HTTP 명세에 추가되지 않은 비표준 헤더

#### 3.5.1 일반 헤더

> 메시지의 종류에 상관없이 유용한 정보 제공

- 일반 캐시 헤더

#### 3.5.2 요청 헤더

> 요청 메시지에서만 의미를 갖는 헤더

- Accept : 클라이언트가 무엇을 원하고 하 ㄹ수 있는지, 원치 않는지 알려준다.
- 조건부 요청 헤더 : 특정 조건에만 응답을 해달라고 요청(Expect, If-Match, Range...)
- 요청 보안 헤더 : 요청을 위한 간단한 인증요구/응답 (14장)
- 프락시 요청 헤더 (6장)

#### 3.5.3 응답 헤더

> 클라이언트에게 부가 정보 제공 (Age, Public, Title ...)

- 협상 헤더 (17장)
- 응답 보안 헤더 (14장)

#### 3.5.4 엔터티 헤더

> HTTP 메시지의 엔터티에 대한 설명. 클라, 서버 모두 나타날 수 있다. (Allow, Location 등)

- 콘텐츠 헤더: 콘텐츠의 종류, 크기 등
- 엔터티 캐싱 헤더: 언제 어떻게 캐시되어야 하나(7장)

## 더 알아봐야할 것

- 상태 코드 예시, 흐름
- 직접 HTTP 메시지 주고 받아보기
