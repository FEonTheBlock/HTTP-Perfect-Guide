# 3장 http 메시지

## 3.1 메시지의 흐름

### 3.1.1 메시지는 원 서버 방향을 인바운드로 하여 송신된다.

인바운드: 메시지가 서버방향으로 향하는것

아웃바운드: 메시지가 사용자 에이전트로 돌아오는 것

### 3.1.2 다운스트림으로 흐르는 메시지

요청, 응답과 관계없이 모든 메시지는 다운스트림으로 흐른다

업스트림이나 다운스트림이란 발송자와 수신자에 대한것이다.

## 3.2 메세지의 각 부분

메시지는 시작줄, 헤더블록, 본문 이렇게 세부분으로 이루어진다

시작줄과 헤더는 줄 단위로 분리된 아스키 문자열이다.

각줄은 CRLF(캐리지 리턴과 개행문자로 구성된 두글자의 줄바꿈 문자열)로 끝난다.

본문은 텍스트나 이진데이터를 포함할 수도 있고 비어있을 수도 있다.

### 3.2.1 메시지 문법

요청메시지 형식

```
<메서드> <요청URL> <버전>
<헤더>
<엔터티 본문>
```

응답메시지 형식

```
<버전> <상태코드> <사유구절>
<헤더>
<엔터티 본문>
```

| 메서드 | 클라이언트 측에서 서버가 리소스에 대해 수행해주길 바라는 동작 |
| --- | --- |
| 요청 URL | 요청 대상이 되는 리소스를 지칭하는 완전한 URL 혹은 URI의 경로 구성요소 |
| 버전 | 메세지에서 사용중인 http 버전 |
| 상태 코드 | 요청 중에 무엇이 일어났는지 설명하는 세자리 숫자다. 각 코드의 첫 번째 자릿수는 상태의 일반적인 분류를 나타낸다. |
| 사유 구절 | 숫자로 된 상태 코드의 의미를 사람이 이해할 수 있게 설명해주는 짧은 문구, 오로지 사람에게 읽히기 위한 목적으로만 존재한다. |
| 헤더들 | 이름, 콜론(:), 선택적인 공백, 값, CRLF가 순서대로 나타나는 0개 이상의 헤더들. CRLF로 끝나 헤더 목록의 끝과 엔터티 본문의 시작을 표시한다 |
| 엔터티 본문 | 임의의 데이터 블록 |

### 3.2.2 시작줄

| 메서드 | 설명 | 본문 유무 |
| --- | --- | --- |
| GET | 서버에서 어떤 문서를 가져온다. | 없음 |
| HEAD | 서버에서 어떤 문서에 대해 헤더만 가져온다 | 없음 |
| POST | 서버가 처리해야 할 데이터를 보낸다 | 있음 |
| PUT | 서버에 요청 메시지의 본문을 저장한다 | 있음 |
| TRACE | 메시지가 프락시를 거쳐 서버에 도달하는 과정을 추적한다 | 없음 |
| OPTIONS | 서버가 어떤 메서드를 수행할 수 있는지 확인한다. | 없음 |
| DELETE | 서버에서 문서를 제거한다. | 없음 |

| 전체 범위 | 정의된 범위 | 분류 |  |
| --- | --- | --- | --- |
| 100-199 | 100-101 | 정보 |  |
| 200-299 | 200-206 | 성공 |  |
| 300-399 | 300-305 | 리다이렉션 | 리소스가 옮겨졌음 |
| 400-499 | 400-415 | 클라이언트 에러 | 클라이언트가 뭔가 잘못된 요청을 했음 |
| 500-599 | 500-505 | 서버 에러 | 서버에서 뭔가 실패했음 |

| 상태 코드 | 사유 구절 | 의미 |
| --- | --- | --- |
| 200 | OK | 성공! 요청한 모든 데이터는 응답 본문에 들어있다. |
| 401 | Unauthorized | 사용자 이름과 비밀번호를 입력해야 한다. |
| 404 | Not Found | 서버는 요청한 URL에 해당하는 리소스를 찾지 못했다. |

버전번호는 어떤 애플리케이션이 지원하는 가장 높은 http 버전을 가리킨다

http/1.1로 된 응답을 받았을 때 http/1.1 메시지가 아니라 응답을 보낸 애플리케이션이 http/1.1까지 이해할 수 있음을 의미한다.

버전 번호는 분수로 다루어지지 않음 → HTTP 버전을 비교할 때는 따로따로 비교해야한다

예시) HTTP/2.22 는 HTTP/2.3 보다 크다. 왜냐하면 22는 3보다 큰 숫자 이기 때문이다.

### 3.2.3 헤더

헤더는 일반 헤더, 요청 헤더, 응답 헤더, entity 헤더, 확장 헤더로 분류된다.

헤더는 이름, 쉼표, 공백(없어도 된다), 필드 값, CRLF가 순서대로 온다.

헤더를 여러 줄로 나누려면 추가 줄 앞에 최소 하나의 스페이스 혹은 탭 문자가 와야한다.

### 3.2.4 엔터티 본문

http 메시지의 화물이라고 할 수 있다.

## 3.3 메서드

### 3.3.1 안전한 메서드

GET과 HEAD메서드는 안전하다고 할 수 있다

→ GET과 HEAD 메서드를 사용하는 HTTP 요청의 결과로 서버에 어떤 작용도 없음을 의미한다

 

### 3.3.3 HEAD

HEAD를 사용하면

- 리소스를 가져오지 않고도 리소스에 대해 알 수 있다.
- 응답의 상태 코드를 통해 개체가 존재하는지 확인할 수 있다.
- 헤더를 확인하여 리소스가 변경되었는지 검사할수 있다.

### 3.3.4 PUT

- 서버가 요청의 본문을 가지고 요청 URL의 이름대로 새 문서를 만들거나, 이미 URL이 존재한다면 본문을 사용해서 교체하는 것이다.
- 서버에 있는 리소스에 데이터를 입력하기 위해 사용한다.

### 3.3.6 TRACE

- ??

### 3.3.8 DELETE

- 서버에게 요청 url로 지정한 리소스를 삭제할 것을 요청한다
- 클라이언트는 삭제가 수행되는 것을 보장하지 못한다
    - http 명세는 서버가 클라이언트에게 알리지 않고 요청을 무시하는 것을 허용하기 때문
    

### 3.3.9 확장 메서드

대표적인 예

| 메서드 | 설명 |
| --- | --- |
| LOCK | 사용자가 리소스를 잠글 수 있게 해준다. 예를 들어, 문서를 편집하는 동안 다른 사람이 편집하지 못하도록 잠글 수 있다. |
| MKCOL | 사용자가 문서를 생성할 수 있게 해준다. |
| COPY | 서버에 있는 리소스를 복사한다. |
| MOVE | 서버에 있는 리소스를 옮긴다. |

## 3.4 상태코드

### 3.4.1 100번대 정보성 상태 코드

???

### 3.4.2 200번대 성공 상태 코드

### 3.4.3 300번대 리다이렉션 상태 코드

- 클라이언트에게 리소스가 옮겨졌으면 어디서 찾을 수 잇는지 알려주기 위해 리다이렉션 상태 코드와 (선택적으로) Location 헤더를 보낼 수 있다.
    - 이는 브라우저가 사용자를 귀찮게 하지 않고 알아서 새 위치로 이동할 수 있게 해준다.
- 리다이렉션 상태 코드 중 몇몇은 리소스에 대한 애플리케이션의 로컬 복사본이 원래 서버와 비교했을 때 유효한지 확인하기 위해 사용된다
    - If-Modified-Since 헤더를 전송하면, 문서가 그 날짜 이후에 변한 것이 없다면 서버는 콘텐츠 대신 304 상태 코드로 답한다.

### 3.4.4 400번대 클라이언트 에러 상태코드

### 3.4.5 500번대 서버에러 상태코드

## 3.5 헤더

일반헤더 - 클라이언트와 서버양쪽 모두 사용

요청헤더 - 클라이언트가 받고자하는 데이터의 부가정보 제공

응답헤더 - 클라이언트에게 정보를 제공하기 위한 헤더

엔터티헤더 - 엔터티본문에 대한 헤더

확장헤더 - 비표준 헤더
