# HTTP 메시지

## 메시지의 흐름

- HTTP 메시지는 HTTP 애플리케이션 간에 주고받은 데이터의 블록들이다.
- 이 데이터의 블록들은 메시지의 내용과 의미를 설명하는 텍스트 메타 정보로 시작하고 그 다음에 선택적으로 데이터가 올 수 있다.
- 이 메시지는 클라이언트, 서버, 프락시 사이를 흐른다.
- 인바운드, 아웃바운드, 업스트림, 다운스트림은 메시지의 방향을 의미하는 용어다.

### 메시지는 원 서버 방향을 인바운드로 하여 송신된다

- HTTP는 인바운드와 아웃바운드라는 용어를 트랜색션 방향을 표현하기 위해 사용한다.
- 메시지가 원 서버로 향하는 것은 인바운드로 이동하는 것이고, 모든 처리가 끝난 뒤에 메시지가 사용자 에이전트로 돌아오는 것은 아웃바운드로 이동하는 것이다.

### 다운스트림으로 흐르는 메시지

HTTP 메시지는 강물과 같이 흐른다. 요청 메시지냐 응답 메시지냐에 관계없이 모든 메시지는 다운스트림으로 흐른다.  
메시지의 발송자는 수신자의 업스트림이다.

## 메시지의 각 부분

HTTP 메시지는 단순한, 데이터의 구조화된 블록이다.  
메시지는 시작줄, 헤더 블록, 본문 이렇게 세 부분으로 이루어진다.  
시작줄은 이것이 어떤 메시지인지 서술하며, 헤더 블록은 속성을, 본문은 데이터를 담고 있다. 이때 본문은 아예 없을 수도 있다.

### 메시지 문법

모든 HTTP 메시지는 요청 메시지나 응답 메시지로 분류된다.  
요청 메시지는 웹 서버에 어떤 동작을 요구하고, 응답 메시지는 요청의 결과를 클라이언트에게 돌려준다.

둘의 형식은 시작줄에서만 문법이 다르다.

**요청 메시지**

```http
<메서드> <요청 URL> <버전>
<헤더>

<엔터티 본문>
```

**응답 메시지**

```http
<버전> <상태 코드> <사유 구절>
<헤더>

<엔터티 본문>
```

- 메서드 : 클라이언트 측에서 서버가 리소스에 대해 수행해주길 바라는 동작
- 요청 URL : 요청 대상이 되는 리소스를 지칭하는 URL
- 버전 : 메시지에서 사용 중인 HTTP의 버전
- 상태 코드 : 요청 중에 무엇이 일어났는지 설명하는 세 자리 숫자.
- 사유 구절 : 숫자로 된 상태코드의 의미를 사람이 이해할 수있게 설명해주는 짧은 문구

### 시작줄

모든 HTTP 메시지는 시작줄로 시작한다.  
요청 메시지의 시작줄은 무엇을 해야 하는지 말해준다.  
응답 메시지의 시작줄은 무슨 일이 일어났는지 말해준다.  
모든 필드는 공백으로 구분된다.

**메서드**  
요청의 시작줄은 메서드로 시작하며, 서버에게 무엇을 해야 하는지 말해준다.  
모든 서버가 모든 종류의 메서드를 구현한 것은 아니다.  
그리고 HTTP는 쉽게 확장할 수 있도록 설계되었기 때문에, 다른 서버는 그들만의 메서드를 추가로 구현했을 수도 있다. 이를 확장 메서드라고 한다.

**상태 코드**  
메서드가 서버에게 무엇을 해야 하는지 말해주는 것처럼, 상태 코드는 클라이언트에게 무엇이 일어났는지 말해준다.  
상태 코드는 숫자로 된 코드와, 문자열로 되어 있어서 사람이 이해하기 쉬운 메시지 두 형태 모두로 반환된다.  
사유 구절이 사람에게 쉽게 읽히는 한편, 숫자로 된 코드는 프로그램이 에러를 처리하기 쉽다.

**사유 구절**  
상태 코드에 대한 글로 된 설명을 제공하며 상태 코드의 사람이 이해하기 쉬운 버전이다.

**버전 번호**  
애플리케이션들이 자신이 따르는 프로토콜의 버전을 상대방에게 말해주기 위한 수단이 된다.  
버전 번호는 HTTP로 대화하는 애플리케이션들에게 대화 상대의 능력과 메시지에 대한 단서를 제공해주기 위한 것이다.  
그리고 버전 번호는 어떤 애플리케이션이 지원하는 가장 높은 HTTP 버전을 가리킨다.

### 헤더

HTTP 헤더 필드는 요청과 응답 메시지에 추가 정보를 더한다.  
이는 기본적으로 이름/값 쌍의 목록이다.

**헤더 분류**

- 일반 헤더: 요청과 응답 양쪽에 모두 나타날 수 있음
- 요청 헤더: 요청에 대한 부가 정보를 제공
- 응답 헤더: 응답에 대한 부가 정보를 제공
- Entity 헤더: 본문 크기와 콘텐츠, 혹은 리소스 그 자체를 서술
- 확장 헤더: 명세에 정의되지 않는 새로운 헤더

### 엔터티 본문

엔터티 본문은 HTTP가 수송하도록 설계된 것들이다.  
HTTP 메시지는 이미지, 비디오, HTML 문서, 소프트웨어 애플리케이션, 신용카드 트랜잭션, 전자우편 등 여러 종류의 디지털 데이터를 실어 나를 수 있다.

### 버전 0.9 메시지

HTTP 버전 0.9는 HTTP 프로토콜의 초기 버전이다. HTTP가 갖고 있는 요청과 응답 메시지의 시초이지만, 훨씬 단순한 프로토콜로 되어 있다.  
지나칠 정도의 단순함 때문에, 다양한 상황에 대응할 수 없다.

## 메서드

### 안전한 메서드

HTTP는 안전한 메서드라 불리는 메서드의 집합을 정의한다.  
GET과 HEAD 메서드는 안전하다고 할 수 있는데, 이는 GET과 HEAD 메서드를 사용하는 HTTP 요청의 결과로 서버에 어떤 작용도 없음을 의미한다.  
서버에 작용이 없다는 것은, HTTP 요청의 결과로 인해 서버에서 일어나는 일은 아무것도 없다는 의미이다.  
안전한 메서드의 목적은, 서버에 어떤 영향을 줄 수 있는 안전하지 않은 메서드가 사용될 때 사용자들에게 그 사실을 알려주는 HTTP 애플리케이션을 만들 수 있도록 하는 것에 있다.

### GET

가장 흔히 쓰이는 메서드로 주로 서버에게 리소스를 달라고 요청하기 위해 쓰인다.

### HEAD

GET처럼 행동하지만, 서버는 응답으로 헤더만을 돌려준다. 엔터티 본문은 결코 반환되지 않는다.  
이는 클라이언트가 리소스를 실제로 가져올 필요 없이 헤더만을 조사할 수 있도록 해준다.

이를 사용하면

- 리소스를 가져오지 않고도 그에 대해 무엇인가를 알아낼 수 있다.
- 응답의 상태 코드를 통해, 개체가 존재하는지 확인할 수 있다.
- 헤더를 확인하여 리소스가 변경되었는지 검사할 수 있다.

### PUT

PUT 메서드는 서버에 문서를 쓴다.  
서버가 요청의 본문을 가지고 요청 URL의 이름대로 새 문서를 만들거나, 이미 URL이 존재한다면 본문을 사용해서 교체하는 것이다.

### POST

서버에 입력 데이터를 전송하기 위해 설계되었다.

### TRACE

클라이언트가 어떤 요청을 할 때, 그 요청은 방화벽, 프락시, 게이트웨이 등의 애플리케이션을 통과할 수 있다.  
이들에게 원래의 HTTP 요청을 수정할 수 있는 기회가 있다.  
TRACE 메서드는 클라이언트에게 자신의 요청이 서버에 도달했을 때 어떻게 보이게 되는지 알려준다.

- TRACE 요청은 목적지 서버에서 루프백 진단을 시작한다.
- 요청 전송의 마지막 단계에 있는 서버는 자신이 받은 요청 메시지를 본문에 넣어 TRACE 응답을 되돌려준다.
- 클라이언트는 자신과 목적지 서버 사이에 있는 모든 HTTP 애플리케이션의 요청/응답 연쇄를 따라가면서 자신이 보낸 메시지가 망가졌거나 수정되었는지, 만약 그렇다면 어떻게 변경되었는지 확인할 수 있다.
- 이는 주로 진단을 위해 사용된다. 프락시나 다른 애플리케이션들이 요청에 어떤 영향을 미치는지 확인해보고자 할 때도 좋은 도구다.
- TRACE는 메서드를 구별하는 메커니즘을 제공하지 않기에 중간 애플리케이션이 여러 다른 종류의 요청들을 일관되게 다룬다고 가정하는 문제가 있다.

### OPTIONS

웹 서버에게 여러 가지 종류의 지원 범위에 대해 물어본다.  
이 메서드는 여러 리소스에 대해 실제로 접근하지 않고도 그것들을 어떻게 접근하는 것이 최선인지 확인할 수 있는 수단을 클라이언트 애플리케이션에게 제공한다.

### DELETE

서버에게 요청한 URL로 지정한 리소스를 삭제할 것을 요청한다.  
그러나 클라이언트는 삭제가 수행되는 것을 보장하지 못한다.

### 확장 메서드

HTTP는 필요에 따라 확장해도 문제가 없도록 설계되어 있으므로, 새로 기능을 추가해도 과거에 구현된 소프트웨어들의 오동작을 유발하지 않는다.  
확장 메서드는 명세에 정의되지 않은 메서드로 개발자들에게 그들의 서버가 구현한 HTTP 서비스의 서버가 관리하는 리소스에 대한 능력을 확장하는 수단을 제공한다.

## 상태 코드

클라이언트에게 그들의 트랜잭션을 이해할 수 있는 쉬운 방법을 제공한다.

### 100-199: 정보성 상태 코드

**100 - Continue**  
요청의 시작 부분 일부가 받아들여졌으며, 클라이언트는 나머지를 계속 이어서 보내야 함을 의미.  
이를 보낸 후, 서버는 반드시 요청을 받아 응답해야 한다.  
서버에 엔터티 본문을 전송하기 전에 그 엔터티 본문을 서버가 받아들일 것인지 확인하려고 할 때, 그 확인 작업을 최적화하기 위한 의도로 도입

만약 클라이언트가 엔터티를 서버에게 보내려고 하고, 그 전에 100 Continue 응답을 기다리겠다면, 클라이언트는 값을 100-continue로 하는 Expect 요청 헤더를 보낼 필요가 있다.  
이는 여러 측면에서 최적화를 위한 것으로 100-continue를 서버가 다루거나 사용할 수 없는 큰 엔터티를 서버에게 보내지 않으려는 목적으로만 사용해야 한다.  
클라이언트 개발자는 예상하지 못한 100 Continue 응답에도 대비해야 한다. 몇몇 잘못 만들어진 HTTP 애플리케이션은 이 코드를 부적절하게 보낸다.

### 200-299: 성공 상태 코드

서버는 대응하는 성공을 의미하는 상태 코드의 배열을 갖고 있으며, 각각 다른 종류의 요청에 대응한다.

**200 - OK**  
요청은 정상이고, 엔터티 본문은 요청한 리소스를 포함하고 있다.

**201 - Created**  
서버 개체를 생성하라는 요청을 위한 것.  
응답은 생성된 리소스에 대한 최대한 구체적인 참조가 담긴 Location 헤더와 함께, 그 리소스를 참조할 수 있는 여러 URL을 엔터티 본문에 포함해야 한다.  
서버는 상태 코드를 보내기에 앞서 반드시 객체를 생성해야 한다.

### 300-399: 리다이렉션 상태 코드

클라이언트가 관심있어 하는 리소스에 대해 다른 위치를 사용하라고 말해주거나 그 리소스의 내용 대신 다른 대안 응답을 제공한다.  
만약 리소스가 옮겨졌다면, 클라이언트에게 리소스가 옮겨졌으며 어디서 찾을 수 있는지 알려주기 위해 리다이렉션 상태 코드와 (선택적으로) Location 헤더를 보낼 수 있다.  
웹 브라우저는 3xx 응답 결과에 Location 헤더가 있으면, 이 위치로 자동 이동한다.

리다이렉션 상태 코드 중 몇몇은 리소스에 대한 애플리케이션의 로컬 복사본이 원래 서버와 비교했을 때 유효한지 확인하기 위해 사용된다.  
ex) 특정 시점 이후 수정된 경우에만 문서를 가져오라고 말하기 위해 If-Modified-Since 헤더를 전송하면 문서가 그 날짜 이후 변한 것이 없다면, 서버는 콘텐츠 대신 304 상태 코드로 답한다.

일반적으로, HEAD가 아닌 요청에 대해 리다이렉션 상태 코드를 포함한 응답을 할 때, 리다이렉트될 URL에 대한 링크와 설명을 포함시키는 것은 좋은 습관이다.

**301 - Moved Permanently**  
요청된 URL이 옮겨졌을 때 사용한다.  
리다이렉트시 요청 메서드가 GET으로 변한다.

**302 - Found**  
클라이언트는 Location 헤더로 주어진 URL을 리소스를 임시로 가리키기 위한 목적으로 사용해야 한다.  
처음 302 스펙의 의도는 HTTP 메서드를 유지하는 것이었지만 웹 브라우저들이 대부분 GET으로 바꾸어버렸다.  
그래서 모호한 302를 대신하는 명확한 307(메서드가 변하면 안됨), 303(메서드가 GET으로 변경)이 등장했고 권장하지만 현실적으로 이미 많은 애플리케이션들이 302를 기본값으로 사용한다.

**PRG: Post/Redirect/GET - 일시적인 리다이렉션 예시**

- POST로 주문후에 새로 고침으로 인한 중복 주문 방지
- POST로 주문후에 주문 결과 화면을 GET 메서드로 리다이렉트
- 새로고침해도 결과 화면을 GET으로 조회
- 중복 주문 대신에 결과 화면만 GET으로 다시 요청

**304 - Not Modified**  
 클라이언트는 헤더를 이용해 조건부 요청을 만들 수 있다.  
만약 클라이언트가 GET과 같은 조건부 요청을 보냈고 그 요청한 리소스가 최근에 수정된 일이 없다면, 이 코드는 리소스가 수정되지 않았음을 의미하게 된다.  
이 상태 코드를 동반한 응답은 엔터티 본문을 가져서는 안 된다. (로컬 캐시를 사용해야 하므로 캐시로 리다이렉트 한다.)  
조건부 GET, HEAD 요청시 사용하며 주로 캐시를 목적으로 사용한다.

### 400-499: 클라이언트 에러 상태 코드

클라이언트의 요청에 잘못된 문법등으로 서버가 요청을 수행할 수 없는 경우 사용  
클라이언트가 이미 잘못된 요청, 데이터를 보내고 있기 때문에, 똑같은 재시도가 실패함. 즉, 요청을 수정해서 보내야 한다.

**400 - Bad Request**  
클라이언트가 잘못된 요청을 해서 서버가 처리할 수 없음  
클라이언트는 요청 내용을 다시 검토하고 보내야 함

**401 - Unauthorized**  
클라이언트가 해당 리소스에 대한 인증이 필요하다.  
응답에 WWW-Authenticate 헤더와 함께 인증 방법을 설명

**403 - Forbiddden**
요청이 서버에 의해 거부되었음을 알려주기 위해 사용한다.  
주로 인증 자격 증명(로그인)은 있지만, 접근 권한이 불충분한 경우 사용한다.

**404 - Not Found**  
서버가 요청한 URL을 찾을 수 없음을 알려주기 위해 사용한다.

### 500-599: 서버 에러 상태 코드

서버 문제로 발생하는 오류에 대한 상태 코드로 서버의 제한에 걸린 것일 수도 있고, 혹은 게이트웨이 리소스와 같은 서버의 보조 구성요소에서 발생한 에러일 수도 있다.  
서버에 문제가 있기 때문에 재시도하면 성공할 수도 있음

**500 - Internal Server Error**  
서버가 요청을 처리할 수 없게 만드는 에러를 만났을 때 사용한다.

**503 - Service Unavailable**  
서버가 일시적인 과부하 또는 예정된 작업으로 잠시 요청을 처리할 수 없음  
Retry-After 헤더 필드로 얼마 뒤에 복구되는지 보낼 수도 있음

## 헤더

헤더에는 특정 종류의 메시지에만 사용할 수 있는 헤더와, 더 일반 목적으로 사용할 수 있는 헤더, 그리고 응답과 요청 메시지 양쪽 모드에서 정보를 제공하는 헤더가 있다.

### 일반 헤더

클라이언트와 서버 양쪽 모두가 사용하는 헤더이다.  
메시지에 대한 아주 기본적인 정보를 제공하며 유용한 정보를 제공한다.

**Date**  
메시지가 언제 만들어졌는지에 대한 날짜와 시간 제공

**Cache-Control**  
메시지와 함께 캐시 지시자를 전달하기 위해 사용한다.

### 요청 헤더

요청 메시지를 위한 헤더로 서버에게 클라이언트가 받고자 하는 데이터의 타입이 무엇인지와 같은 부가 정보를 제공한다.

**Host**  
요청의 대상이 되는 서버의 호스트 명과 포트를 준다.  
하나의 IP 주소에 여러 도메인이 적용되어 있을 때 사용된다.

**Referer**  
현재 요청된 페이지의 이전 웹 페이지 주소  
Referer를 사용해서 유입 경로 분석이 가능하다.

**Accept 관련 헤더**  
클라이언트는 Accept 관련 헤더들을 이용해 서버에게 자신의 선호와 능력을 알려줄 수 있다.  
서버는 이 추가 정보를 활용해서 무엇을 보낼 것인가에 대해 더 똑똑한 결정을 내릴 수 있다.  
이를 통해 클라이언트는 원하는 것을 얻을 수 있으며, 서버는 클라이언트가 사용할 수 없는 것을 전송하는 데 시간과 대역폭을 낭비하지 않을 수 있다.

- Accept: 클라이언트가 선호하는 미디어 타입 전달
- Accept-Charset: 클라이언트가 선호하는 문자 인코딩
- Accept-Encoding: 클라이언트가 선호하는 압축 인코딩
- Accept-Language: 클라이언트가 선호하는 자연 언어

**조건부 요청 헤더**  
클라이언트가 어떤 문서의 사본을 가지고 있는 상태라면, 클라이언트는 서버에게 그 문서를 요청할 때 자신이 갖고 있는 사본과 다를 때만 전송해 달라고 요청하고 싶을 수 있다.  
조건부 요청 헤더를 사용하면, 클라이언트는 서버에게 요청에 응답하기 전에 먼저 조건이 참인지 확인하게 하는 제약을 포함시킬 수 있다.

- Expect: 클라이언트가 요청에 필요한 서버의 행동을 열거할 수 있게 해준다.
- If-None-Match: 문서의 엔터티 태그가 주어진 엔터티 태그와 일치하지 않는 경우에만 문서를 가져온다.
- If-Modified-Since: 주어진 날짜 이후에 리소스가 변경된 경우에만 문서를 가져온다

**요청 보안 헤더**  
HTTP는 자체적으로 요청을 위한 간단한 인증요구/응답 체계를 갖고 있다.  
요청하는 클라이언트가 어느 정도의 리로스에 접근하기 전에 자신을 인증하게 함으로써 트랜잭션을 더 안전하게 만ㄷ르고자 한다.

- Authorization: 클라이언트가 서버에게 제공하는 인증 그 자체에 대한 정보를 담고 있다.
- Cookie: 클라이언트가 서버에게 토큰을 전달할 때 사용한다.

**프락시 요청 헤더**  
프락시의 기능을 돕기 위한 헤더

### 응답 헤더

응답 메시지는 클라이언트에게 정보를 제공하기 위한 자신만의 헤더를 갖고 있다.  
이는 클라이언트에게 부가 정보를 제공한다.

**Server**  
요청을 처리하는 서버 애플리케이션의 이름과 버전

**Retry-After**  
현재 리소스가 사용 불가능한 상태일 때, 언제 가능해지는지 날짜 또는 시각

**협상 헤더**  
서버에 여러 언어로 번역된 문서가 있는 경우 여러 가지 표현이 가능한 상황이라면, 어떤 표현을 택할 것인가에 대해 협상을 할 수 있도록 지원한다.

**응답 보안 헤더**

- set-Cookie: 서버가 클라이언트를 인증할 수 있도록 클라이언트 측에 토큰을 설정하기 위해 사용
- WWW-Authenticate: 서버에서 클라이언트로 보낸 인증 요구의 목록

### 엔터티 헤더

엔터티 본문에 대한 헤더로 엔터티 본문에 들어있는 데이터의 타입이 무엇인지 말해줄 수 있다.  
요청과 응답 양타입의 메시지에 모두 나타날 수 있다.  
일반적으로 엔터티 헤더는 수신자에게 자신이 다루고 있는 것이 무엇인지 말해준다.

**Location**  
클라이언트에게 엔터티가 실제로 어디에 위치하고 있는지 말해준다.  
웹 브라우저는 3xx 응답 결과에 Location 헤더가 있으면, 해당 위치로 자동 이동시킨다.

**콘텐츠 헤더**  
엔터티의 콘텐츠에 대한 구체적인 정보를 제공한다.

- Content-Type: 표현 데이터의 형식
- Content-Encoding: 표현 데이터에 적용된 인코딩
- Content-Language: 표현 데이터를 이해하는데 가장 적절한 자연어
- Content-Length: 표현 데이터의 길이

**엔터티 캐싱 헤더**  
엔터티 캐싱에 대한 정보를 제공

- ETag: 엔터티에 대한 엔터티 태그
- Last-Modified: 가장 최근 이 엔터티가 변경된 일시
