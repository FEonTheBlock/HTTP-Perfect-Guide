# 14장 | 보안 HTTP

## HTTP를 안전하게 만들기

> HTTP 보안 버전은 효율적이고, 이식성이 좋아야 하고, 관리가 쉬워야 하며, 현실 세계의 변화에 대한 적응력이 좋아야 하고, 사회와 정부의 요구사항에도 맞아야 한다.<br>
> 이를 위해 아래와 같은 기능을 제공하는 HTTP 보안 기술이 필요하다.

- 서버 인증: 클라이언트는 자신이 위조된 서버가 아닌 진짜와 이야기하고 있음을 알 수 있어야 한다.
- 클라이언트 인증: 서버는 자신이 가짜가 아닌 진짜 사용자와 이야기하고 있음을 알 수 있어야 한다.
- 무경성: 클라이언트와 서버는 그들의 데이터가 위조되는 것으로부터 안전해야 한다.
- 암호화: 클라이언트와 서버는 도청에 대한 걱정 없이 서로 대화할 수 있어야 ㅎ나다.
- 효율: 저렴한 클라이언트나 서버도 이용할 수 있도록 알고리즘은 충분히 빨라야한다.
- 편재성: 프로토콜은 거의 모든 클라이언트와 서버에서 지원되어야 한다.
- 관리상 확장성: 누구든 어디서든 즉각적인 보안 통신을 할 수 있어야 한다.
- 적응성: 현재 알려진 최선의 보안 방법을 지원해야한다.
- 사회적 생존성: 사회의 문화적, 정치적 요구를 만족시켜야 한다.

### HTTPS

> HTTPS는 HTTP를 안전하게 만드는 방식 중 가장 인기 있는 것이다.
> <br> HTTPS를 사용하면 모든 HTTP 요청과 응답 데이터는 네트워크로 보내지기 전에 암호화 된다.

## 디지털 암호학

### 기술과 용어

- 암호: 텍스트를 아무나 읽지 못하도록 인코딩하는 알고리즘
- 키: 암호의 동작을 변경하는 숫자로 된 매개변수
- 대칭키 암호 체계: 인코딩과 디코딩에 같은 키를 사용하는 알고리즘
- 비대칭키 암호 체계: 인코딩과 디코딩에 다른 키를 사용하는 알고리즘
- 공개키 암호법: 비밀 메세지를 전달하는 수백만 대의 컴퓨터를 쉽게 만들 수 있는 시스템
- 디지털 서명: 메세지가 위조 혹은 변조되지 않았음을 입증하는 체크섬
- 디지털 인증서: 신뢰할만한 조직에 의해 서명되고 검증된 신원 확인 정보

### 비밀 코드의 기술과 화학

> 암호법은 메세지 인코딩과 디코딩에 대한 과학이자 기술

### 암호

> 암호법: 암호라 불리는 비밀 코드에 기반한다.
> <br>암호: 메세지를 인코딩하는 특정한 방법과 나중에 해당 비밀 메세지를 디코딩하는 방법

### 암호 기계

> 암호는 처음에는 간단한 알고리즘으로 시작했지만, 기술이 진보하며 복잡한 암호로 인코딩하고 디코딩하는 기계를 만들기 시작했다.

### 키가 있는 암호

> 키에 따라 디코딩이 다르게 동작한다.
> <br> 오늘날 거의 대부분의 암호 알고리즘은 키를 사용한다.

### 디지털 암호

- 속도 및 기능에 대한 기계 장치의 한계에서 벗어남으로서, 복잡한 인코딩과 디코딩 알고리즘이 가능해졌다.
- 크기가 큰 키를 지원하는 것이 가능해져 단일 암호 알고리즘으로 키의 값마다 다른 수조개의 가상 암호 알고리즘을 만들어낼 수 있게 되었다.

## 대칭키 암호법

> 인코딩과 디코딩할 때 사용하는 키가 같은 것

### 키 길이와 열거 공격

> 평범한 대칭키 암호는 오늘날 슈퍼 컴퓨터로 간단하게 뚫린다.
> <br> 때문에 키 사용 시 비트수가 높은 것을 사용하는 것이 암호를 지키는데에 안전하다.

### 공유키 발급하기

> 대칭키 암호화의 대표적 단점으로 송신자와 수신자가 서로 대화하기 위해서는 둘 모두가 공유키를 가져야 한다는 것이다.

만약 N개의 노드가 있고, 각 노드가 `N - 1` 상대와 은밀하게 대화를 나누어야 한다면, 대략 `N ^ 2`개의 비밀 키가 필요하다.

## 공개키(비대칭키) 암호법

> 한 쌍의 호스트가 하나의 인코딩/디코딩 키를 사용하는 대신 공개키 암호 방식은 두 개의 비대칭 키를 사용한다.

- 인코딩 키: 모두가 알 수 있는 공개키
- 디코딩 키: 호스트만이 갖고 있는 개인키

### RSA

비대칭 암호의 과제는 아래의 내용을 알고 있더라도 개인키를 계산할 수 없다는 것을 확신시켜주는 것이다.

- 공개키
- 네트워크 스누핑을 통해 가로채서 얻은 암호문의 일부
- 메세제와 이를 암호화한 암호문

이를 만족하는 암호 체계 중 유명한 하나가 MIT에서 개발한 RSA 알고리즘

### 혼성 암호 체계와 세션 키

> 공개키 암호화 방식의 알고리즘은 계산이 느린 경향이 있다.

이 때문에 노드 간 연결을 맺고 이후 나머지 데이터를 암호화할 때는 더 빠른 대칭키를 사용하는 방식이 흔히 쓰인다.

## 디지털 서명

> 암호 체계는 누가 메세지를 썼는지 알려주고 이 메세지가 위조되지 않았음을 증명하기 위해 메세지에 서명 하도록 하는데에 사용될 수 있다.

### 서명은 암호 체크섬이다

> 디지털 서명은 메세지에 붙어있는 특별한 암호 체크섬으로서 메세지를 작성한 저자가 누구인지 알려주고 메세지 위조를 방지한다.

## 디지털 인증서

> 디지털 인증서는 인터넷의 신분증이며 신뢰할 수 있는 기관으로부터 보증 받은 사용자나 회사에 대한 정보를 담고 있다.

### 인증서의 내부

> 디지털 인증서에는 공식적으로 인증 기관에 의해 디지털 서명된 정보의 집합이 담겨있다.

- 대상의 이름
- 유효 기간
- 인증서 발급자
- 인증서 발급자의 디지털 서명

### X.509 v3 인증서

디지털 인증서에 대한 전 세계적인 단일 표준은 없지만, 오늘날 사용되는 대부분의 인증서가 그들의 정보를 X.509라 불리는 표준화된 서식에 저장하고 있다.

### 서버 인증을 위해 인증서 사용하기

사용자가 HTTPS를 통한 안전한 웹 트랜잭션을 시작할 때, 최신 브라우저는 자동으로 접속한 서버에서 디지털 인증서를 가져오고 이를 검사한다.

## HTTPS의 세부사항

> HTTPS는 HTTP 프로토콜에 대칭, 비대칭 인증서 암호 기법의 강력한 집합을 결합하여 분권화되 글로벌 환경에서도 HTTPS를 매우 안전한 동시에 유연하고 관리하기 쉽게 만들어 준다.

### HTTPS 개요

> HTTPS는 HTTP 메시지를 TCP로 보내기 전에 먼저 그것들을 암호화하는 보안 계층으로 보낸다.

오늘날 HTTPS 보안 계층은, SSL과 그것의 현대적 대체품인 TLS로 구현되었다.

### HTTPS 스킴

> https로 시작하는 스킴 접두사를 가진다.

또한 클라이언트는 서버에 443번 포트로 연결하고 서버와 바이너리 포매승로 된 몇몇 SSL 보안 매개변수를 교환하면서 '핸드셰이크'를 하고, 암호화된 HTTP 명령이 뒤를 잇는다.

### 보안 전송 셋업

> HTTPS에서의 절차는 TCP 연결이후, 클라이언트와 서버간 암호법 매개변수와 교환 키를 협상하면서 SSL 계층을 초기화한다.

핸드셰이크 완료 후 SSL 초기화가 완료되며, 클라이언트는 요청 메시지를 보안 계층에 보내는데, 이 메시지는 암호화되어 보내진다.

### SSL 핸드셰이크

- 프로토콜 버전 번호 교환
- 양쪽이 알고 있는 암호 선택
- 양쪽의 신원 인증
- 채널을 암호화하기 위해 임시 세션키 생성

### 서버 인증서

서버 인증서는 조직의 이름, 주소, 서버 DNS 도메인 이름, 그외 정보를 보여주는 X.509 v3에서 파생된 인증서 이다.

### 사이트 인증서 검사

> 웹 서버 인증서 검사를 위한 알고리즘의 단계는 아래와 같다.

1. 날짜 검사: 인증서가 유효한지 확인하기위해 시작 및 종료일을 검사
2. 서명자 신뢰도 검사: 어떤 인증 기관에의해 서명되었는지 확인한다.
3. 서명 검사: 공개키를 서명에 적용하여 체크섬 검사한다.
4. 사이트 신원 검사: 인증서의 도메인 이름과 서버의 도메인 이름과 비교하여 맞는지 검사한다.

### 가상 호스팅과 인증서

가상 호스팅으로 운영되는 사이트는 인증서와 관련하여 다루기 까다로운 문제가 있어서 보통 이를 피하기 위해 리다이렉트하는 방법을 사용한다.

### 프락시를 통한 보안 트래픽 터널링

> 프락시를 사용한다면, 클라이언트가 서버로 데이터를 보낼때 암호화하면 더 이상 HTTP 헤더를 읽을 수 없다.

이러한 경우 사용하는 것이 HTTPS SSL 터널링 프로토콜 이다. 이를 사용하면 클라이언트는 이 내용을 프락시가 읽을 수 있도록 암호화가 시작되기 전에 평문으로 말해준다.

<br>

# 15장 엔터티와 인코딩

> HTTP는 아래와 같은 내용을 보장한다.

- 객체는 올바르게 식별되므로(Content-Type 미디어 포맷과 Content-Language 헤더를 이용해서) 브라우저나 다른 클라이언트는 콘텐츠를 바르게 처리할 수 있다.
- 객체는 올바르게 압축이 풀릴 것이다.(Content-Length와 Content-Encoding 헤더를 이용해서)
- 객체는 항상 최신이다(엔터티 검사기와 캐시 만료 제어를 이용해서)
- 사용자는 요구를 만족할 것이다(내용 협상을 위한 Accept 관련 헤더들에 기반해서)
- 네트워크 사이를 빠르고 효율적으로 이동할 것이다(범위 요청, 델타 인코딩, 그 외의 데이터 압축을 이용해서)
- 조작되지 않고 온전하게 도착할 것이다(전송 인코딩 헤더와 체크섬을 이용해서)

## HTTP/1.1의 10가지 주요 엔터티 헤더 필드

- Content-Type: 엔터티에 의해 전달된 객체의 종류
- Content-Length: 전달되는 메시지의 길이나 크기
- Content-Language: 전달되는 객체와 가장 잘 대응되는 자연어
- Content-Encoding: 객체 데이터에 대해 행해진 변형(압축 등)
- Content-Location: 요청 시점을 기준으로, 객체의 또 다른 위치
- Content-Range: 부분 엔터티라면, 이 헤더는 이 엔터티가 전체에서 어느 부분에 해당하는지 정의
- Content-MD5: 엔터티 본문의 콘텐츠에 대한 체크섬
- Last-Modified: 서버에서 이 콘텐츠가 생성 혹은 수정된 날
- Expires: 이 엔터티 데이터가 더 이상 신선하지 않은 것으로 간주되기 시작하는 날짜와 시각
- Allow: 이 리소스에 대해 어떤 요청 메서드가 허용 되는지
- ETag: 이 인스턴스에 대한 고유한 검사기
- Cache-Control: 어떻게 이 문서가 캐시될 수 있는지에 대한 지시자

## Content-Length: 엔터티의 길이

> `Content-Length` 헤더는 메세지의 엔터티 본문의 크기를 바이트 단위로 나타낸다.

서버 충돌로 인해 메세지가 잘렸는지 감지하고자 할 때와 지속 커넥션을 공유하는 메세지를 올바르게 분할하고자 할 때 필요하다.

### 잘림 검출

> `Content-Length` 헤더가 없다면 클라이언트는 커넥션이 정상적으로 닫힌 것인지 메시지 전송 중에 서버에 충돌이 발생한 것인지 구분하지 못한다.

메세지 잘림은 캐싱 프락시 서버에서 특히 취약한데, 만약 캐시가 잘린 메세지를 수신했으나 잘렸다는 것을 인지하지 못했다면 캐시는 결함이 있는 콘텐츠를 저장하고 이를 계속해서 제공하기 때문이다.

### 잘못된 Content-Length

> Content-Length가 잘못된 값을 담고 있는 경우 아예 빠진 것보다도 큰 피해를 유발할 수 있다.

### Content-Length와 지속 커넥션

> `Content-Length`는 지속 커넥션을 하기 위해 필수다.
> <br> `Content-Length`헤더는 클라이언트에게 메세지 하나가 어디서 끝나고 다음 시작은 어디인지 알려준다.

다만 청크 인코딩을 사용할때는 `Content-Length`헤더 없는 지속 커넥션이 가능하다.

### 콘텐츠 인코딩

> HTTP는 보안을 강화하거나 압축을 통해 공간을 절약할 수 있도록 엔터티 본문을 인코딩할 수 있다.

### 엔터티 본문 길이 판별을 위한 규칙

1. 본문을 갖는 것이 허용되지 않는 HTTP 메시지에는, 본문 계산을 위한 `Content-Length` 헤더가 무시된다.
2. 메시지가 `Transfer-Encoding` 헤더를 포함하고 있다면, 메시지가 커넥션이 닫혀서 먼저 끝나지 않는 이상 엔터티는 0바이트 청크라 불리는 특별한 패턴으로 끝나야 한다.
3. `Content-Length` 헤더를 갖는다면 본문의 길이를 담게 된다.
4. 메시지가 `multipart/byteranges` 미디어 타입을 사용하고 엔터티 길이가 별도로 정의되지 않았다면, 멀티파트 메시지의 각 부분은 각자 스스로의 크기를 정의할 것이다. 이 멀티파트 유형은 스스로 크기를 결정할 수 있는 유일한 엔터티 본문 유형이다.
5. 위의 어떤 규칙에도 해당되지 않는다면, 엔터티는 커넥션이 닫힐 때 끝난다.

## 엔터티 요약

> HTTP가 일반적으로 `TCP/IP`와 같이 신뢰할만한 전송 프로토콜 위에서 구현되지만, 여러 이유로 메세지의 일부분이 전송 중에 변형되는 일이 발생한다.

이런 변경을 감지하기 위해, 최초 엔터티가 생성될 때 송신자는 데이터에 대한 체크섬을 생성할 수 있으며, 수신자는 의도하지 않은 엔터티의 변경을 잡아내기 위해 해당 체크섬으로 기본적인 검사를 할 수 있다.

`Content-MD5` 헤더는 서버가 엔터티 본문에 MD5 알고리즘을 적용한 결과를 보내기 위해 사용된다.
<br>응답을 처음 만든 서버만이 Content-MD5 헤더를 계산해서 보내고, 중간에 있는 프락시와 캐시는 그 헤더를 변경하거나 추가하지 않는다.

## 미디어 타입과 차셋(Charset)

> `Content-Type` 헤더 필드는 엔터티 본문의 `MIME` 타입을 기술한다.

`MIME` 타입이란 전달되는 데이터 매체의 기저 형식의 표준화된 이름이다.

### 텍스트 매체를 위한 문자 인코딩

`Content-Type` 헤더는 `charset`매개변수를 지원해 내용 유형을 더 자세히 지정할 수 있다.

### 멀티파트 미디어 타입

> `MIME 멀티파트` 이메일 메시지는 서로 붙어있는 여러 개의 메시지를 포함하며 하나의 복합 메시지로 보내진다.

### 멀티파트 폼 제출

HTTP 폼을 채워서 제출하면, 가변 길이 텍스트 필드와 업로드 될 객체는 각각이 멀티파트 본문을구성하는 하나의 파트가 되어 보내진다.

### 멀티파트 범위 응답

> 범위 요청에 대한 HTTP 응답 또한 멀티파트가 될 수 있다.

## 콘텐츠 인코딩

> HTTP 애플리케이션은 이따금 콘텐츠를 보내기 전에 인코딩을 하려고 한다.
> <br>이를 통해 전송 시간을 줄이거나 암호화하는데 이점을 챙길 수 있기 때문

### 콘텐츠 인코딩 과정

1. 웹 서버가 원본 Content-Type과 Content-Length 헤더를 수반한 원본 응답 메시지를 생성한다.
2. 콘텐츠 인코딩 서버가 인코딩 메시지를 생성한다. 콘텐츠 인코딩 서버는 Content-Encoding 헤더를 추가하여, 수신 측 애플리케이션이 그것을 디코딩할 수 있도록 한다.
3. 수신 측 프로그램은 인코딩된 메시지를 받아서 디코딩하고 원본을 얻는다.

### 콘텐츠 인코딩 유형

> HTTP는 몇 가지 표준 콘텐츠 인코딩 유형을 정의하고 확장 인코딩으로 인코딩을 추가하는 것도 허용한다.

gzip 인코딩은 전송되는 메시지의 크기를 정보의 손실 없이 줄이기 위한 무손실 압축 알고리즘이다. gzip은 일반적으로 가장 효율적이고 가장 널리 쓰이는 압축 알고리즘이다.

### Accept-Encoding 헤더

> 서버에서 클라이언트가 지원하지 않는 인코딩을 사용하는 것을 막기 위해, 클라이언트는 자신이 지원하는 인코딩 목록을 Accept-Encoding 요청 헤더를 통해 전달한다.

## 전송 인코딩과 청크 인코딩

> 메세지 데이터가 네트워크를 통해 전송되는 방법을 바꾸기 위해 전송 인코딩을 메세지에 적용할 수 있다.

## 안전한 전송

> 전송 인코딩은 다른 프로토콜에서도 네트워크를 통한 안전한 전송을 위해 존재했다.

### 알 수 없는 크기

몇몇 콘텐츠 인코더는 콘텐츠를 먼저 생성하지 않고서는 메시지 본문의 최종 크기를 판단할 수 없다.  
서버들은 사이즈를 알기 전에 데이터의 전송을 시작하려 한다.
<br>HTTP는 데이터에 앞서 Content-Length를 요구하기 때문에, 몇몇 서버는 종결 꼬리말을 포함시켜 전송 인코딩으로 데이터를 보내려 시도한다.

### 보안

전송 인코딩을 사용할 수도 있지만 SSL과 같은 방식을 더 선호함

### 청크 인코딩

> 데이터를 각각이 특정한 크기를 갖는 일련의 청크들로 쪼개어 보내는것

### 전송 인코딩 규칙

- 전송 인코딩의 집합은 반드시 'chunked'를 포함해야 한다. 유일한 예외는 메시지가 커넥션의 종료로 끝나는 경우 뿐이다.
- 청크 전송 인코딩이 사용되었다면, 메시지 본문에 적용된 마지막 전송 인코딩이 존재해야 한다.
- 청크 전송 인코딩은 반드시 메시지 본문에 한 번 이상 적용되어야 한다.

## 시간에 따라 바뀌는 인스턴스

> 웹 객체는 정적이지 않고 시간에 따라 다른 버전의 객체를 가리킬 수 있다.
> <br>HTTP 프로토콜은 특정한 종류의 요청이나 응답을 다루는 방법들을 정의하는데, 이를 인스턴스 조작이라 부른다.

대표적인 두 가지 인스턴스 조작

- 범위 요청
- 델타 인코딩

## 검사기와 신선도

### 신선도

서버는 클라이언트에게 얼마나 오랫동안 콘텐츠를 캐시하고 그것이 신선하다고 가정할 수 있는지에 대한 정보를 줄 것이다.
<br>서버는 Expires나 Cache-Control 헤더를 통해 이러한 정보를 제공할 수 있다.

### 조건부 요청과 검사기

> HTTP는 클라이언트에게 리소스가 바뀐 경우에만 사본을 요청하는 조건부 요청이라 불리는 특별한 요청을 할 수 있는 방법을 제공한다.

조건부 요청은 평범한 요청 메시지이지만, 특정 조건이 참일 때만 수행된다.
<br>조건부 요청은 `If-` 로 시작하는 조건부 헤더에 의해 구현된다.

## 범위 요청

> 클라이언트가 문서의 일부분이나 특정 범위만 요청할 수 있도록 해주는 것

클라이언트의 범위 요청은 오직 클라이언트와 서버가 같은 버전의 문서를 갖고 있을 때만 의미가 있다.

## 델타 인코딩

> 델타 인코딩은 객체 전체가 아닌 변경된 부분에 대해서만 통시한여 전송량을 최적화하는, HTTP 프로토콜의 확장이다.

새 페이지 전체를 보내는 대신, 페이지에 대한 클라이언트의 사본에 대해 변경된 부분만을 서버가 보내면 클라이언트는 더 빨리 페이지를 얻을 수 있게 된다.

하지만 구현에 까다롭고, 문서 제공 시간이 줄어드는 대신 서버가 문서의 과거 사본을 모두 유지하기 위해 디스크 공간을 더 소모해야하며 이는 전송량 감소로 얻을 수 있는 이득을 무의미하게 만들기에 충분하다.
