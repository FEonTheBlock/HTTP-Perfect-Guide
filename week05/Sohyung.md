## 들어가며

HTTP 완벽 가이드 5장 웹서버를 정리한다.

- 여러 종류의 소프트웨어 및 하드웨어 웹 서버세 대해 조사
- HTTP 통신을 진단해주는 간단한 웹 서버를 Perl로 작성
- 어떻게 웹 서버가 HTTP 트랜잭션을 처리하는지 단계별로 설명

추가적으로 원활한 이해를 위해 다음 개념도 함께 정리한다.

- tcp 흐름제어
- 혼잡제어
- 오류제어

## 5장 웹서버

> 웹서버는 HTTP 요청을 처리하고 응답을 제공한다.

### 5.1 다채로운 웹 서버

소프트웨어와 웹페이지 제공에 특화된 장비(컴퓨터와 같은) 양쪽 모두를 의미한다. 종류는 다양하지만 모두 '리소스에 대한 HTTP 요청을 받아서 콘텐츠를 클라이언트에게 돌려'준다.

즉, 웹 서버는 HTTP 및 그와 관련된 TCP 처리를 구현한 것이다.

#### 웹 서버의 다양한 형태

1. 다목적 소프트웨어 웹 서버: 네트워크에 연결된 표준 컴퓨터 시스템에서 동작한다.

- 오픈소스 소프트웨어(아파치, W3C 의 직소 등)
- 상용 소프트웨어(마이크로소프트, 아이플래닛 등)이 있다.

- 2022 웹서버 점유율
![webserver_occu](https://user-images.githubusercontent.com/65655597/159099677-926a93c6-7f3b-43d4-b57a-cef369507511.JPG)

2. 임베디드 웹 서버 : 일반 소비자용 제품(프린터, 가전제품 등)에 내장될 목적으로 만들어진 작은 웹 서버

- (IOT에 활용되는 Arduino 등)

- 임베디드 웹 서버 예시: 공용세탁기 원격 제어 서비스
  - 공용세탁기에 Arduino 임베디드 웹 서버를 활용해 세탁기가 작동 중인지 아닌지를 감지   
  ![washing_machine](https://user-images.githubusercontent.com/65655597/159099691-695555c0-e0ec-4437-9f66-f4790780554a.JPG) 
  
  ![washing_machine2](https://user-images.githubusercontent.com/65655597/159099714-a21ce5d9-3495-4da0-91ec-f6426afbbe76.JPG)
  
3. (추가 조사) 서버리스 웹 애플리케이션
모든 서버관리를 특정 업체가 대신하도록 하는 것. 대표적으로 AWS가 있고, 이곳에서는 오픈소스 소프트웨어, 상용 소프트웨어 모두 사용 가능하다.
![serverless_app_architecture](https://user-images.githubusercontent.com/65655597/159100053-392d8259-b354-4038-a58f-82028fae1e62.png)

### 5.2 간단한 펄 웹 서버

> 사용자에게 요청을 받으면 TCP 소켓을 연결하고 시작 메세지를 출력, 사용자에게 입력 메세지를 받을 때까지 기다리다가 받은 후에 브라우저에 해당 메세지를 응답하고 종료하는 서버(type-o-serve)를 제작해보는 파트다.

### 5.3 진짜 웹 서버가 하는 일

1. 커넥션 맺기 : 클라이언트의 접속을 받아들이거나 원치 않는 클라이언트는 닫기
2. 요청 받기 : HTTP 요청 메시지를 네트워크로부터 읽어 들이기
3. 요청을 처리한다 : 요청 메시지를 해석하고 행동을 취한다.
4. 리소스에 접근한다 : 메시지에서 지정한 리소스에 접근한다
5. 응답을 만든다 : 올바른 헤더를 포함한 HTTP 응답 메시지를 생성한다.
6. 응답을 보낸다 : 응답을 라이언트에게 돌려준다.
7. 트랜잭션을 로그로 남긴다 : 로그파일에 트랜잭션 완료에 대한 기록을 남긴다.

### 5.4 단계1 : 클라이언트 커넥션 수락

- 새 커넥션 다루기
- 클라이언트 호스트 명 식별
- ident를 통해 클라이언트 사용자 알아내기 (성능,보안,사용성 등의 이유로 잘 사용하지 않음)

### 5.5 단계 2: 요청 메시지 수신

- 수신 후 처리 방법

  - 요청줄을 파싱하여 URI, 버전 번호를 찾는다. CRLF로 끝남
  - 메시지 헤더들을 읽는다. 각 헤더는 CRLF로 끝남
  - 헤더의 끝을 의미하는 CRLF가 있다면 찾는다.
  - 요청 본문이 있다면 읽어들인다. (Content-Length 헤더로 정의됨)

- 커넥션 입/출력 아키텍쳐 (보완 필요)
  - 단일 스레드 웹 서버
  - 멀티프로세스와 멀티스레드 웹 서버

### 5.6 단계3: 요청 처리

요청으로부터 메서드, 리소스, 헤더, 본문을 언어낸 후 요구된 요청을 처리한다.

### 5.7 단계4: 리소스의 매핑과 접근

- docroot
  - 일반적으로 docroot라고 불리는 웹 콘텐츠를 위한 웹 서버 파일 시스템의 문서 루트가 있다. httpd.conf 설정 파일의 DocumentRoot로 설정할 수 있다. 이 docroot 가 공개되지 않도록 주의해야 한다.

- 가상 호스팅 웹 서버 docroot
  - 가상 호스팅 웹 서버는 그들만의 루트 분리 방법을 이용해 하나의 웹 서버에 여러 개의 웹 사이트를 호스팅한다.

- 사용자 홈 디렉터리 docroots
  - `/~` 를 이용해 사용자들이 한 대의 웹 서버에서 각자의 개인 웹 사이트를 만들 수 있도록 한다.

- 요청 경로가 파일이 아니라 디렉터리를 가리킬 때?

  - 에러 반환
  - 색인 파일 반환
    - 아파치 웹서버에서 `Directorylndex` 키로 설정할 수 있다.
    - `Directorylndex index.html index.htm home.html home.htm index.cgi`
  - 디렉터리를 탐색해서 그 내용을 담은 html 페이지를 반환
    - 편리하지만 너무 공개적이다.

> 동적 콘텐츠 리소스 매핑

> 서버사이드 인클루드(Server-Side Includes, SSI)

> 접근 제어

### 5.8 단계 5: 응답 만들기

- MIME 타입 결정하기

  - mime.types (파일 이름의 확장자로 알기)
  - Magic typing (파일 내용 검사 후 정하기)
  - Explicit typing (서버 맘대로 정하기)
  - Type negotiation (여러 종류의 문서 형식에 속하도록 설정, 가장 좋은 형식 판별)

- 리다이렉션
  - 영구히 리소스가 옮겨진 경우
  - 임시로 리소스가 옮겨진 경우
  - URL 증강
    - 상태정보를 내포한 새 URL을 생성하여 리다이렉트 시킨 후, 여기서 다시 요청을 보낸다. 트랜잭션 간 상태 유지 방법
    - 303 See Other, 307 Temporary Redirect
  - 친밀한 다른 서버
  - 디렉터리 이름 정규화
    - /을 빠뜨리면 상대결로가 정상적으로 동작할 수 있도록 슬래시를 추가한 URI로 리다이렉트

### 5.9 단계 6: 응답 보내기

여러 클라이언트에 대한 많은 커넥션을 가질 수 있기 때문에 커넥션 상태에 대해 주의를 기울여야 한다.

### 5.10 단계 7: 로깅

트랜잭션이 완료되었을 때 로그파일에 로드를 기록한다. 자세한 설정 양식은 21장 참고.

## 추가 조사

### tcp 흐름제어(Flow control)

수신측이 송신측보다 데이터 처리 속도가 빠르면 문제없지만, 송신측의 속도가 빠를 경우 문제가 생긴다. 수신측에서 제한된 저장 용량을 초과한 이후에 도착하는 데이터는 손실 될 수 있으며, 만약 손실 된다면 불필요하게 응답과 데이터 전송이 송/수신 측 간에 빈번이 발생한다. 이러한 위험을 줄이기 위해 송신 측의 데이터 전송량을 수신측에 따라 조절해야한다.

즉,
- 수신측이 송신측의 데이터 처리 속도를 따라가지 못하는 경우를 방지하기 위한 것
- receiver가 packet을 지나치게 많이 받지 않도록 조절하는 것
- 기본 개념은 receiver가 sender에게 현재 자신의 상태를 feedback 한다는 점

- 방법
  - Stop and Wait : 매번 전송한 패킷에 대해 확인 응답을 받아야만 그 다음 패킷을 전송하는 방법
  - Sliding Window (오류 제어 : Go Back N ARQ)
    - 수신측에서 설정한 윈도우 크기만큼 송신측에서 확인응답없이 세그먼트를 전송할 수 있게 하여 데이터 흐름을 동적으로 조절하는 제어기법
    - 먼저 윈도우에 포함되는 모든 패킷을 전송하고, 그 패킷들의 전달이 확인되는대로 이 윈도우를 옆으로 옮김으로써 그 다음 패킷들을 전송

### 혼잡 제어

송신측의 데이터는 지역망이나 인터넷으로 연결된 대형 네트워크를 통해 전달된다. 만약 한 라우터에 데이터가 몰릴 경우, 자신에게 온 데이터를 모두 처리할 수 없게 된다. 이런 경우 호스트들은 또 다시 재전송을 하게되고 결국 혼잡만 가중시켜 오버플로우나 데이터 손실을 발생시키게 된다. 
따라서 이러한 네트워크의 혼잡을 피하기 우해 송신측에서 보내는 데이터의 전송속도를 강제로 줄이게 되는데, 이러한 작업을 혼잡제어라고 한다.

또한 네트워크 내에 패킷의 수가 과도하게 증가하는 현상을 혼잡이라 하며, 혼잡 현상을 방지하거나 제거하는 기능을 혼잡제어라고 한다.

흐름제어가 송신측과 수신측 사이의 **전송속도**를 다루는데 반해, 혼잡제어는 **호스트와 라우터를포함한 보다 넓은 관점**에서 전송 문제를 다루게 된다.

![image](https://user-images.githubusercontent.com/65655597/159100572-9850f93e-f8eb-43c7-8ba4-41cce684d547.png)

- AIMD(Additive Increase / Multiplicative Decrease)
  - 처음에 패킷을 하나씩 보내고 이것이 문제없이 도착하면 window 크기(단위 시간 내에 보내는 패킷의 수)를 1씩 증가시켜가며 전송하는 방법
  - 패킷 전송에 실패하거나 일정 시간을 넘으면 패킷의 보내는 속도를 절반으로 줄인다.
  - 공평한 방식으로, 여러 호스트가 한 네트워크를 공유하고 있으면 나중에 진입하는 쪽이 처음에는 불리하지만, 시간이 흐르면 평형상태로 수렴하게 되는 특징이 있다.
  - 문제점은 초기에 네트워크의 높은 대역폭을 사용하지 못하여 오랜 시간이 걸리게 되고, 네트워크가 혼잡해지는 상황을 미리 감지하지 못한다. 즉, 네트워크가 혼잡해지고 나서야 대역폭을 줄이는 방식이다.
- Slow Start (느린 시작)

  - AIMD 방식이 네트워크의 수용량 주변에서는 효율적으로 작동하지만, 처음에 전송 속도를 올리는데 시간이 오래 걸리는 단점이 존재했다.
  - Slow Start 방식은 AIMD와 마찬가지로 패킷을 하나씩 보내면서 시작하고, 패킷이 문제없이 도착하면 각각의 ACK 패킷마다 window size를 1씩 늘려준다. 즉, 한 주기가 지나면 window size가 2배로 된다.
  - 전송속도는 AIMD에 반해 지수 함수 꼴로 증가한다. 대신에 혼잡 현상이 발생하면 window size를 1로 떨어뜨리게 된다.
    처음에는 네트워크의 수용량을 예상할 수 있는 정보가 없지만, 한번 혼잡 현상이 발생하고 나면 네트워크의 수용량을 어느 정도 예상할 수 있다. 그러므로 혼잡 현상이 발생하였던 window size의 절반까지는 이전처럼 지수 함수 꼴로 창 크기를 증가시키고 그 이후부터는 완만하게 1씩 증가시킨다.

- Fast Retransmit (빠른 재전송)

  - 빠른 재전송은 TCP의 혼잡 조절에 추가된 정책이다.
  - 패킷을 받는 쪽에서 먼저 도착해야할 패킷이 도착하지 않고 다음 패킷이 도착한 경우에도 ACK 패킷을 보내게 된다.
  - 단, 순서대로 잘 도착한 마지막 패킷의 다음 패킷의 순번을 ACK 패킷에 실어서 보내게 되므로, 중간에 하나가 손실되게 되면 송신 측에서는 순번이 중복된 ACK 패킷을 받게 된다. 이것을 감지하는 순간 문제가 되는 순번의 패킷을 재전송 해줄 수 있다.
    중복된 순번의 패킷을 3개 받으면 재전송을 하게 된다. 약간 혼잡한 상황이 일어난 것이므로 혼잡을 감지하고 window size를 줄이게 된다.

- Fast Recovery (빠른 회복)
  - 혼잡한 상태가 되면 window size를 1로 줄이지 않고 반으로 줄이고 선형증가시키는 방법이다. 이 정책까지 적용하면 혼잡 상황을 한번 겪고 나서부터는 순수한 AIMD 방식으로 동작하게 된다.

### 오류 제어

- Go Back N
  - 송신측에서 여러개의 데이터를 연속적으로 보내다가 오류가 발생한 데이터부터 다시 재전송하는 방식을 사용한다.
  - 단점 : 불필요한 재전송을 한다.
- Selective N
  - 오류가 발생한 패킷만 재전송한다.
  - 장점 : 불필요한 재전송이 없다.
  - 단점 : 수신측의 버퍼에 순서가 보장되지 않는다. 따라서 수신 버퍼에 대한 재정렬이 필요하고, 이는 필연적으로 또 다른 버퍼 공간을 필요로 한다.

## 더 알아봐야할 것

-

## 참고 링크
- [TCP/IP (흐름제어/혼잡제어)](https://gyoogle.dev/blog/computer-science/network/%ED%9D%90%EB%A6%84%EC%A0%9C%EC%96%B4%20&%20%ED%98%BC%EC%9E%A1%EC%A0%9C%EC%96%B4.html)
- [AWS 서버리스 웹 애플리케이션 소개](https://aws.amazon.com/ko/serverless/build-a-web-app/)
