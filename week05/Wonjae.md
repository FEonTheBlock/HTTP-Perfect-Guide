# TCP 흐름 제어, 혼잡 제어, 오류 제어

## 흐름 제어

> 송신측과 수신측의 데이터 처리 속도 차이를 해결하기 위한 기법

수신측에서 받을 수 있는 데이터 한도보다 더 많은 데이터가 들어오면 초과된 데이터들은 손실될 수 있다.

### Stop and Wait

> 매번 전송한 패킷에 대해 확인응답을 받아야만 다음 패킷을 전송하는 방법

패킷을 하나씩 보내기 때문에 비효율적

### Sliding Window

> 수신측에서 설정한 위도우 크기만큼 송신측에서 확인응답 없이 세그먼트를 전송할 수 있게 하여 흐름을 동적으로 조절하는 기법

윈도우에 포함된 패킷을 계속 전송하고, 수신 측으로부터 확인 응답이 오면 윈도우를 옆으로 옮겨 다음 패킷들을 전송한다.

### 재전송

> 수신측으로부터 확인 응답을 받지 못하면, 패킷을 재전송

통상적으로 타이머를 이용해 구현

## 혼잡 제어

> 송신측의 데이터 전달과 네트워크 데이터 처리속도를 해결하기 위한 기법

한 라우터에 데이터가 몰릴 경우 데이터를 모두 처리하지 못하며 재전송하게 되고 이로 인해 오버플로우 또는 데이터 손실을 발생시키며 네트워크 혼잡 현상이 생긴다.
<br>이를 해결하지 위해 송신측에서 송신하는 패킷 수를 조절하는 작업을 혼잡제어라 한다.

### AIMD

> 합 증가 곱 감소

- 패킷을 보내고 문제 없으면 window의 크기를 1씩 증가
- 실패하면 패킷의 보내는 속도를 절반으로 감소
- 초기 네트워크 대역폭을 사용하지 못해 오랜시간이 걸리고, 혼잡현상이 발생하고 나서야 대역폭을 줄이는 방식이다.

### Slow Start

- 윈도우의 크기를 1 -> 2 -> 4 -> 8과 같이 제곱으로 증가 시킨다.
- 혼잡이 발생하면 window size를 1로 떨어뜨린다.
- 혼잡현상이 발생한 뒤, 네트워크 수용량을 예측하여 그 절반까지 이전처럼 증가시키고 이후로는 완만하게 1씩 증가시킨다.

### Fast Retransmit

- 패킷을 받는 수신자 입장에서는 세그먼트로 분할된 내용들이 순서대로 도착하지 않을 수 있다.
- 이러한 경우 잘 도착한 마지막 패킷의 다음 순번을 `ACK` 패킷에 실어 보낸다.
- 이런 중복 `ACK` 패킷을 3번 받게 되는 경우 재전송이 이루어진다.

### Fast Recovery

- 혼잡한 상태가 되면 window size를 1로 줄이지 않고 반으로 줄이며 선형증가 시킨다.
- 이후 혼잡 상황을한번 겪고 나서부터는 순수한 AIMD 방식으로 동작한다.

## 오류 제어

> 훼손된 패킷을 감지하고 손실된 패킷은 재전송하고, 순서에 맞지 않는 세그먼트를 버퍼에 저장하는 일을 함

### Stop And Wait

> 송신 측에서 패킷을 보내고 보낸 패킷에 대한 응답이 오면 다음 패킷을 보냄

하지만 `Sliding Window`기법을 사용하면 데이터를 연속적으로 보내는 방식이라 의미가 없기 때문에 재전송 기반의 오류제어, `ARQ(Automatic Repeat Request)`를 사용

### ARQ

> TCP는 기본적으로 재전송 기반의 오류 제어를 사용한다.
> <br>하지만 많은 데이터를 주고 받아야하는 상황에서 이러한 방법은 비효율적이므로 재전송을 최소화하는 방식으로 TCP는 오류를 제어한다.

**1) Go-Back-M**

> 여러개의 데이터를 연속적으로 보내다가 오류가 발생한 데이터부터 재전송하는 방식

이미 수신한 데이터를 폐기하고 다시 재전송해야한다는 단점이 있다.

**2) Selective Repeat**

> 오류가 발생한 데이터만 골라서 재전송하는 방식

재정렬이 필요하다는 점에서 또 다른 버퍼 공간을 사용한다.
